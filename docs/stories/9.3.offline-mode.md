# Story 9.3: Offline Mode & Data Sync

## Status
Draft

## Story
**As a** player with unreliable internet,
**I want** to view my characters and dice rolls offline,
**so that** I can reference my character sheet and roll dice without connection.

## Acceptance Criteria
1. Character sheets viewable offline (cached from last online visit)
2. Dice roller fully functional offline
3. "You are offline" indicator shown in UI when disconnected
4. Offline actions queued and synced when connection restored
5. Character list shows cached characters when offline
6. Dice roll history saved locally (IndexedDB)
7. Table chat shows "Offline - messages will send when reconnected"
8. Background sync sends queued messages when online

## Tasks / Subtasks

- [ ] Implement offline detection (AC: 3)
  - [ ] Listen to `navigator.onLine` changes
  - [ ] Listen to `online` and `offline` events
  - [ ] Create useOnline hook
  - [ ] Show offline banner in UI

- [ ] Cache character data (AC: 1, 5)
  - [ ] Service worker caches GET `/api/characters`
  - [ ] Service worker caches GET `/api/characters/:id`
  - [ ] IndexedDB stores character data as backup
  - [ ] Show cached characters when offline

- [ ] Make dice roller offline-first (AC: 2)
  - [ ] Dice roller uses only client-side logic
  - [ ] No API calls needed for dice rolls
  - [ ] Save roll history to IndexedDB
  - [ ] Sync roll history when online (optional)

- [ ] Create offline indicator component (AC: 3)
  - [ ] Banner: "You are offline. Some features unavailable."
  - [ ] Show at top of page
  - [ ] Yellow background, warning icon
  - [ ] Auto-hide when back online

- [ ] Implement action queue (AC: 4)
  - [ ] Queue POST/PATCH requests when offline
  - [ ] Store in IndexedDB: `offlineQueue` table
  - [ ] Process queue when back online
  - [ ] Handle failures gracefully

- [ ] Set up IndexedDB (AC: 6, 7)
  - [ ] Create database: `iarpg-offline`
  - [ ] Stores: characters, diceRolls, messageQueue
  - [ ] Use idb library for easier IndexedDB access

- [ ] Cache character sheets (AC: 1)
  - [ ] Service worker intercepts character API calls
  - [ ] Cache responses in CacheStorage
  - [ ] Fallback to cache when offline
  - [ ] Show "Viewing cached version" notice

- [ ] Handle offline chat (AC: 7)
  - [ ] Detect offline in chat component
  - [ ] Show "Offline" indicator in message input
  - [ ] Queue messages in IndexedDB
  - [ ] Disable send button (or queue on click)

- [ ] Implement background sync (AC: 8)
  - [ ] Register background sync in service worker
  - [ ] Sync event processes queued messages
  - [ ] Send messages to API
  - [ ] Clear queue on success

- [ ] Create useOfflineQueue hook (AC: 4)
  - [ ] Function `queueAction(action)`
  - [ ] Function `processQueue()`
  - [ ] Auto-process when online
  - [ ] Show "Syncing..." indicator

- [ ] Store dice rolls locally (AC: 6)
  - [ ] Save each roll to IndexedDB
  - [ ] Limit to 100 most recent rolls
  - [ ] Show history in dice roller
  - [ ] Clear old rolls after 7 days

- [ ] Handle conflicts (AC: 4)
  - [ ] Character updated offline + online â†’ conflict
  - [ ] Show "Conflict detected" modal
  - [ ] Options: Keep local, Keep server, Merge
  - [ ] Timestamp-based resolution (last write wins)

- [ ] Test offline scenarios (AC: 1-8)
  - [ ] Disconnect WiFi, test character sheet
  - [ ] Disconnect WiFi, test dice roller
  - [ ] Queue message, reconnect, verify sync
  - [ ] Test offline indicator appears/disappears
  - [ ] Test cached character list

## Dev Notes

### Offline Detection Hook
**[Source: React hooks for online/offline detection]**

```typescript
// apps/web/src/hooks/useOnline.ts
'use client';

import { useEffect, useState } from 'react';

export function useOnline(): boolean {
  const [isOnline, setIsOnline] = useState(true);

  useEffect(() => {
    // Initialize
    setIsOnline(navigator.onLine);

    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
}
```

### Offline Indicator Component
```typescript
// apps/web/src/components/OfflineIndicator.tsx
'use client';

import { useOnline } from '@/hooks/useOnline';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { WifiOff } from 'lucide-react';

export function OfflineIndicator() {
  const isOnline = useOnline();

  if (isOnline) return null;

  return (
    <Alert variant="warning" className="fixed top-0 left-0 right-0 z-50 rounded-none border-yellow-500 bg-yellow-500/20">
      <WifiOff className="h-4 w-4" />
      <AlertDescription>
        You are offline. Some features may be unavailable. Your actions will sync when reconnected.
      </AlertDescription>
    </Alert>
  );
}
```

**Add to layout:**
```tsx
import { OfflineIndicator } from '@/components/OfflineIndicator';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <OfflineIndicator />
        {children}
      </body>
    </html>
  );
}
```

### IndexedDB Setup
**[Source: idb library for IndexedDB]**

```bash
pnpm add idb
```

```typescript
// apps/web/src/lib/db.ts
import { openDB, DBSchema, IDBPDatabase } from 'idb';

interface OfflineDB extends DBSchema {
  characters: {
    key: string;
    value: {
      id: string;
      data: any;
      timestamp: number;
    };
  };
  diceRolls: {
    key: number;
    value: {
      id: number;
      notation: string;
      result: number;
      timestamp: number;
    };
    indexes: { timestamp: number };
  };
  messageQueue: {
    key: number;
    value: {
      id: number;
      tableId: string;
      content: string;
      timestamp: number;
    };
    indexes: { timestamp: number };
  };
}

let dbPromise: Promise<IDBPDatabase<OfflineDB>> | null = null;

export function getDB(): Promise<IDBPDatabase<OfflineDB>> {
  if (!dbPromise) {
    dbPromise = openDB<OfflineDB>('iarpg-offline', 1, {
      upgrade(db) {
        // Characters store
        if (!db.objectStoreNames.contains('characters')) {
          db.createObjectStore('characters', { keyPath: 'id' });
        }

        // Dice rolls store
        if (!db.objectStoreNames.contains('diceRolls')) {
          const rollStore = db.createObjectStore('diceRolls', {
            keyPath: 'id',
            autoIncrement: true,
          });
          rollStore.createIndex('timestamp', 'timestamp');
        }

        // Message queue store
        if (!db.objectStoreNames.contains('messageQueue')) {
          const queueStore = db.createObjectStore('messageQueue', {
            keyPath: 'id',
            autoIncrement: true,
          });
          queueStore.createIndex('timestamp', 'timestamp');
        }
      },
    });
  }

  return dbPromise;
}

// Characters
export async function cacheCharacter(id: string, data: any) {
  const db = await getDB();
  await db.put('characters', { id, data, timestamp: Date.now() });
}

export async function getCachedCharacter(id: string) {
  const db = await getDB();
  const cached = await db.get('characters', id);
  return cached?.data;
}

export async function getCachedCharacters() {
  const db = await getDB();
  const all = await db.getAll('characters');
  return all.map((c) => c.data);
}

// Dice Rolls
export async function saveDiceRoll(notation: string, result: number) {
  const db = await getDB();
  await db.add('diceRolls', {
    id: Date.now(),
    notation,
    result,
    timestamp: Date.now(),
  });

  // Keep only last 100 rolls
  const all = await db.getAll('diceRolls');
  if (all.length > 100) {
    const oldest = all.sort((a, b) => a.timestamp - b.timestamp).slice(0, all.length - 100);
    for (const roll of oldest) {
      await db.delete('diceRolls', roll.id);
    }
  }
}

export async function getDiceRollHistory() {
  const db = await getDB();
  const all = await db.getAll('diceRolls');
  return all.sort((a, b) => b.timestamp - a.timestamp);
}

// Message Queue
export async function queueMessage(tableId: string, content: string) {
  const db = await getDB();
  await db.add('messageQueue', {
    id: Date.now(),
    tableId,
    content,
    timestamp: Date.now(),
  });
}

export async function getQueuedMessages() {
  const db = await getDB();
  return await db.getAll('messageQueue');
}

export async function clearMessageQueue() {
  const db = await getDB();
  await db.clear('messageQueue');
}
```

### Service Worker Cache Strategy for Characters
```javascript
// public/sw.js (updated)

// Fetch: Custom strategy for characters API
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Characters API: Cache-first with network fallback
  if (url.pathname.match(/^\/api\/characters/)) {
    event.respondWith(
      caches.match(request).then((cachedResponse) => {
        if (cachedResponse) {
          // Return cached, but update in background
          fetch(request).then((response) => {
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(request, response.clone());
            });
          });
          return cachedResponse;
        }

        // No cache, fetch from network
        return fetch(request).then((response) => {
          if (response.status === 200) {
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(request, response.clone());
            });
          }
          return response;
        });
      })
    );
    return;
  }

  // ... other fetch strategies
});
```

### Character Sheet with Offline Support
```typescript
// apps/web/src/app/characters/[characterId]/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useOnline } from '@/hooks/useOnline';
import { getCachedCharacter, cacheCharacter } from '@/lib/db';
import { Character } from '@iarpg/db';
import { Alert, AlertDescription } from '@/components/ui/alert';

export default function CharacterPage({ params }: { params: { characterId: string } }) {
  const [character, setCharacter] = useState<Character | null>(null);
  const [isFromCache, setIsFromCache] = useState(false);
  const isOnline = useOnline();

  useEffect(() => {
    fetchCharacter();
  }, [params.characterId, isOnline]);

  const fetchCharacter = async () => {
    if (isOnline) {
      // Try network first
      try {
        const response = await fetch(`/api/characters/${params.characterId}`);
        const data = await response.json();
        setCharacter(data.character);
        setIsFromCache(false);

        // Cache for offline use
        await cacheCharacter(params.characterId, data.character);
      } catch (error) {
        console.error('Failed to fetch character:', error);
        loadFromCache();
      }
    } else {
      // Offline: load from cache
      loadFromCache();
    }
  };

  const loadFromCache = async () => {
    const cached = await getCachedCharacter(params.characterId);
    if (cached) {
      setCharacter(cached);
      setIsFromCache(true);
    }
  };

  if (!character) return <div>Loading...</div>;

  return (
    <div>
      {isFromCache && (
        <Alert variant="info" className="mb-4">
          <AlertDescription>
            Viewing cached version. Changes may not reflect latest updates.
          </AlertDescription>
        </Alert>
      )}

      <CharacterSheet character={character} />
    </div>
  );
}
```

### Offline-First Dice Roller
```typescript
// apps/web/src/components/DiceRoller.tsx (updated)
'use client';

import { useState, useEffect } from 'react';
import { saveDiceRoll, getDiceRollHistory } from '@/lib/db';
import { Button } from '@/components/ui/button';

export function DiceRoller() {
  const [result, setResult] = useState<number | null>(null);
  const [history, setHistory] = useState<any[]>([]);

  useEffect(() => {
    loadHistory();
  }, []);

  const loadHistory = async () => {
    const rolls = await getDiceRollHistory();
    setHistory(rolls.slice(0, 10)); // Last 10 rolls
  };

  const rollDice = async (sides: number, modifier = 0) => {
    const roll = Math.floor(Math.random() * sides) + 1;
    const total = roll + modifier;
    setResult(total);

    // Save to IndexedDB (works offline)
    await saveDiceRoll(`1d${sides}${modifier !== 0 ? ` ${modifier >= 0 ? '+' : ''}${modifier}` : ''}`, total);

    // Reload history
    await loadHistory();
  };

  return (
    <div className="space-y-4">
      {/* Dice buttons */}
      <div className="grid grid-cols-3 gap-3">
        {[4, 6, 8, 10, 12, 20].map((sides) => (
          <Button key={sides} onClick={() => rollDice(sides)}>
            d{sides}
          </Button>
        ))}
      </div>

      {/* Result */}
      {result !== null && (
        <div className="text-4xl font-bold text-center">{result}</div>
      )}

      {/* History */}
      <div className="space-y-2">
        <h3 className="font-bold">Recent Rolls</h3>
        {history.map((roll) => (
          <div key={roll.id} className="flex justify-between text-sm">
            <span>{roll.notation}</span>
            <span className="font-bold">{roll.result}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Offline Message Queue
```typescript
// apps/web/src/components/ChatInput.tsx (updated)
'use client';

import { useState } from 'react';
import { useOnline } from '@/hooks/useOnline';
import { queueMessage } from '@/lib/db';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { toast } from 'sonner';

export function ChatInput({ tableId }: { tableId: string }) {
  const [message, setMessage] = useState('');
  const isOnline = useOnline();

  const sendMessage = async () => {
    if (!message.trim()) return;

    if (isOnline) {
      // Send immediately
      await fetch(`/api/tables/${tableId}/messages`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: message }),
      });
    } else {
      // Queue for later
      await queueMessage(tableId, message);
      toast.info('Message queued. Will send when reconnected.');
    }

    setMessage('');
  };

  return (
    <div className="flex gap-2">
      <Input
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        placeholder={isOnline ? 'Type a message...' : 'Offline - messages will queue'}
        onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
      />
      <Button onClick={sendMessage}>
        {isOnline ? 'Send' : 'Queue'}
      </Button>
    </div>
  );
}
```

### Background Sync
**[Source: Background Sync API]**

```javascript
// public/sw.js (updated)

// Register background sync tag
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-messages') {
    event.waitUntil(syncMessages());
  }
});

async function syncMessages() {
  // Get queued messages from IndexedDB
  const db = await openDB('iarpg-offline', 1);
  const messages = await db.getAll('messageQueue');

  for (const msg of messages) {
    try {
      // Send to API
      await fetch(`/api/tables/${msg.tableId}/messages`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: msg.content }),
      });

      // Remove from queue
      await db.delete('messageQueue', msg.id);
    } catch (error) {
      console.error('Failed to sync message:', error);
      // Keep in queue for next sync
    }
  }
}
```

**Register sync in client:**
```typescript
// apps/web/src/hooks/useOfflineSync.ts
'use client';

import { useEffect } from 'react';
import { useOnline } from './useOnline';

export function useOfflineSync() {
  const isOnline = useOnline();

  useEffect(() => {
    if (isOnline && 'serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype) {
      // Trigger background sync
      navigator.serviceWorker.ready.then((registration) => {
        registration.sync.register('sync-messages');
      });
    }
  }, [isOnline]);
}
```

### Conflict Resolution
```typescript
// apps/web/src/utils/conflictResolution.ts
interface ConflictData {
  local: any;
  server: any;
  localTimestamp: number;
  serverTimestamp: number;
}

export function detectConflict(local: any, server: any): boolean {
  // Simple check: different updatedAt timestamps
  return local.updatedAt !== server.updatedAt;
}

export function resolveConflict(
  conflict: ConflictData,
  strategy: 'local' | 'server' | 'last-write-wins'
): any {
  if (strategy === 'local') {
    return conflict.local;
  }

  if (strategy === 'server') {
    return conflict.server;
  }

  if (strategy === 'last-write-wins') {
    return conflict.localTimestamp > conflict.serverTimestamp
      ? conflict.local
      : conflict.server;
  }

  return conflict.server; // Default
}
```

### Testing

**Test scenarios:**
- Disconnect WiFi, view character sheet (shows cached version)
- Disconnect WiFi, roll dice (works offline, saves to IndexedDB)
- Disconnect WiFi, offline indicator appears
- Reconnect WiFi, offline indicator disappears
- Queue message while offline, reconnect, message sends
- View character list offline (shows cached characters)
- View dice roll history offline
- Background sync triggers when reconnecting
- Queued messages clear after successful sync
- Conflict detection works when local + server differ
- Last-write-wins strategy resolves conflicts correctly
- IndexedDB stores data correctly
- Service worker caches character API responses
- Cached data shows "Viewing cached version" notice

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
