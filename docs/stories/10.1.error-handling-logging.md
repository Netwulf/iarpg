# Story 10.1: Error Handling & Logging System

## Status
Draft

## Story
**As a** developer,
**I want** comprehensive error handling and logging,
**so that** I can debug issues quickly and monitor application health.

## Acceptance Criteria
1. All API errors return consistent JSON format: `{ error, message, statusCode }`
2. Global error handler catches unhandled errors in Express
3. Frontend shows user-friendly error messages (not stack traces)
4. Winston logger configured for structured logging
5. Logs include: timestamp, level, message, context (userId, tableId)
6. Log levels: error, warn, info, debug
7. Errors logged to file in production: `logs/error.log`, `logs/combined.log`
8. Sentry integration for error tracking (optional)

## Tasks / Subtasks

- [ ] Install logging libraries (AC: 4)
  - [ ] `pnpm add winston winston-daily-rotate-file` (backend)
  - [ ] `pnpm add @sentry/node @sentry/nextjs` (optional)
  - [ ] Configure Winston logger

- [ ] Create Winston logger instance (AC: 4, 5, 6)
  - [ ] Create `apps/api/src/lib/logger.ts`
  - [ ] Levels: error, warn, info, http, debug
  - [ ] Format: timestamp, level, message, metadata
  - [ ] Transports: Console (dev), File (prod)

- [ ] Configure log rotation (AC: 7)
  - [ ] Daily rotate file transport
  - [ ] Max file size: 20MB
  - [ ] Max files: 14 days
  - [ ] Separate error.log and combined.log

- [ ] Create global error handler (AC: 2)
  - [ ] Middleware: `errorHandler(err, req, res, next)`
  - [ ] Log all errors with Winston
  - [ ] Return consistent error format
  - [ ] Hide stack traces in production

- [ ] Standardize error responses (AC: 1)
  - [ ] Custom error classes: AppError, ValidationError, NotFoundError
  - [ ] Error factory functions
  - [ ] Consistent error format across all endpoints

- [ ] Add request logging (AC: 5)
  - [ ] Log all incoming requests: method, path, status, duration
  - [ ] Include userId if authenticated
  - [ ] Include requestId for tracing
  - [ ] Use Morgan or custom middleware

- [ ] Implement frontend error handling (AC: 3)
  - [ ] Global error boundary component
  - [ ] Toast notifications for API errors
  - [ ] User-friendly error messages
  - [ ] "Something went wrong" fallback UI

- [ ] Create error utility functions (AC: 1)
  - [ ] `handleApiError(error)` - parse and display
  - [ ] `isNetworkError(error)` - check connection
  - [ ] `getErrorMessage(error)` - extract message

- [ ] Add Sentry integration (AC: 8 - optional)
  - [ ] Initialize Sentry in backend
  - [ ] Initialize Sentry in frontend
  - [ ] Capture unhandled errors
  - [ ] Capture handled exceptions
  - [ ] Tag errors with userId, environment

- [ ] Log critical events (AC: 5)
  - [ ] User authentication (login, logout, failed attempts)
  - [ ] Subscription changes (upgrade, downgrade, cancel)
  - [ ] AI API calls (model, tokens, cost, errors)
  - [ ] Payment events (success, failure)

- [ ] Create logger context helper (AC: 5)
  - [ ] Function: `logger.withContext({ userId, tableId })`
  - [ ] Automatically includes context in all logs
  - [ ] Middleware adds request context

- [ ] Add log viewer (AC: 7)
  - [ ] Admin endpoint: GET `/api/admin/logs`
  - [ ] Query params: level, startDate, endDate, limit
  - [ ] Stream logs from files
  - [ ] Requires admin role

- [ ] Test error scenarios (AC: 1-7)
  - [ ] Trigger 404 Not Found
  - [ ] Trigger 500 Internal Server Error
  - [ ] Trigger validation error
  - [ ] Check error.log created
  - [ ] Check combined.log created
  - [ ] Verify log format
  - [ ] Test error boundary in frontend

## Dev Notes

### Winston Logger Setup
**[Source: Winston logging library documentation]**

```bash
pnpm add winston winston-daily-rotate-file
```

```typescript
// apps/api/src/lib/logger.ts
import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';

const isDevelopment = process.env.NODE_ENV === 'development';

// Custom format
const customFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

// Console format for development
const consoleFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: 'HH:mm:ss' }),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    let metaStr = '';
    if (Object.keys(meta).length > 0) {
      metaStr = JSON.stringify(meta, null, 2);
    }
    return `${timestamp} [${level}]: ${message} ${metaStr}`;
  })
);

// Transports
const transports: winston.transport[] = [];

// Console transport (always enabled)
transports.push(
  new winston.transports.Console({
    format: isDevelopment ? consoleFormat : customFormat,
  })
);

// File transports (production only)
if (!isDevelopment) {
  // Error log
  transports.push(
    new DailyRotateFile({
      filename: 'logs/error-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      level: 'error',
      maxSize: '20m',
      maxFiles: '14d',
      format: customFormat,
    })
  );

  // Combined log
  transports.push(
    new DailyRotateFile({
      filename: 'logs/combined-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d',
      format: customFormat,
    })
  );
}

// Create logger
export const logger = winston.createLogger({
  level: isDevelopment ? 'debug' : 'info',
  format: customFormat,
  transports,
  exitOnError: false,
});

// Add context helper
export function createContextLogger(context: Record<string, any>) {
  return {
    error: (message: string, meta?: any) =>
      logger.error(message, { ...context, ...meta }),
    warn: (message: string, meta?: any) =>
      logger.warn(message, { ...context, ...meta }),
    info: (message: string, meta?: any) =>
      logger.info(message, { ...context, ...meta }),
    http: (message: string, meta?: any) =>
      logger.http(message, { ...context, ...meta }),
    debug: (message: string, meta?: any) =>
      logger.debug(message, { ...context, ...meta }),
  };
}
```

**Usage:**
```typescript
import { logger, createContextLogger } from './lib/logger';

// Simple logging
logger.info('Server started', { port: 3000 });
logger.error('Database connection failed', { error: err.message });

// With context
const contextLogger = createContextLogger({ userId: 'user123', tableId: 'table456' });
contextLogger.info('User joined table');
```

### Custom Error Classes
```typescript
// apps/api/src/utils/errors.ts
export class AppError extends Error {
  statusCode: number;
  isOperational: boolean;

  constructor(message: string, statusCode = 500, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 404);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message = 'Unauthorized') {
    super(message, 401);
  }
}

export class ForbiddenError extends AppError {
  constructor(message = 'Forbidden') {
    super(message, 403);
  }
}

export class ConflictError extends AppError {
  constructor(message: string) {
    super(message, 409);
  }
}
```

**Usage:**
```typescript
import { NotFoundError, ValidationError } from '../utils/errors';

// In controller
const user = await prisma.user.findUnique({ where: { id: userId } });
if (!user) {
  throw new NotFoundError('User');
}

if (!req.body.name) {
  throw new ValidationError('Name is required');
}
```

### Global Error Handler Middleware
**[Source: Express error handling best practices]**

```typescript
// apps/api/src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors';
import { logger } from '../lib/logger';

export function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) {
  let error = err;

  // Convert non-AppError to AppError
  if (!(error instanceof AppError)) {
    const statusCode = (error as any).statusCode || 500;
    const message =
      process.env.NODE_ENV === 'production'
        ? 'Internal server error'
        : error.message;

    error = new AppError(message, statusCode, false);
  }

  const appError = error as AppError;

  // Log error
  logger.error('Error occurred', {
    message: appError.message,
    statusCode: appError.statusCode,
    stack: appError.stack,
    url: req.originalUrl,
    method: req.method,
    userId: (req as any).user?.id,
    body: req.body,
  });

  // Send response
  res.status(appError.statusCode).json({
    error: true,
    message: appError.message,
    statusCode: appError.statusCode,
    ...(process.env.NODE_ENV === 'development' && { stack: appError.stack }),
  });
}

// 404 handler
export function notFoundHandler(req: Request, res: Response, next: NextFunction) {
  const error = new AppError(`Route ${req.originalUrl} not found`, 404);
  next(error);
}
```

**Register in Express:**
```typescript
// apps/api/src/server.ts
import { errorHandler, notFoundHandler } from './middleware/errorHandler';

// ... routes

// 404 handler (after all routes)
app.use(notFoundHandler);

// Global error handler (must be last)
app.use(errorHandler);
```

### Request Logging Middleware
```typescript
// apps/api/src/middleware/requestLogger.ts
import { Request, Response, NextFunction } from 'express';
import { logger } from '../lib/logger';
import { v4 as uuidv4 } from 'uuid';

export function requestLogger(req: Request, res: Response, next: NextFunction) {
  const requestId = uuidv4();
  const startTime = Date.now();

  // Attach requestId to request
  (req as any).requestId = requestId;

  // Log when response finishes
  res.on('finish', () => {
    const duration = Date.now() - startTime;

    logger.http('HTTP Request', {
      requestId,
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userId: (req as any).user?.id,
      ip: req.ip,
    });
  });

  next();
}
```

**Register:**
```typescript
// apps/api/src/server.ts
import { requestLogger } from './middleware/requestLogger';

app.use(requestLogger);
```

### Frontend Error Boundary
**[Source: React Error Boundary pattern]**

```typescript
// apps/web/src/components/ErrorBoundary.tsx
'use client';

import React from 'react';
import { Button } from '@/components/ui/button';
import { AlertTriangle } from 'lucide-react';

interface ErrorBoundaryProps {
  children: React.ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);

    // Send to error tracking service (Sentry)
    if (typeof window !== 'undefined' && (window as any).Sentry) {
      (window as any).Sentry.captureException(error, { extra: errorInfo });
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center p-4">
          <div className="text-center max-w-md">
            <AlertTriangle className="h-16 w-16 text-red-500 mx-auto mb-4" />
            <h1 className="text-2xl font-bold mb-2">Something went wrong</h1>
            <p className="text-gray-400 mb-6">
              We're sorry for the inconvenience. Please try refreshing the page.
            </p>

            {process.env.NODE_ENV === 'development' && this.state.error && (
              <pre className="text-left bg-gray-800 p-4 rounded text-xs overflow-auto mb-4">
                {this.state.error.message}
              </pre>
            )}

            <Button onClick={() => window.location.reload()}>
              Refresh Page
            </Button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**Wrap app:**
```tsx
// apps/web/src/app/layout.tsx
import { ErrorBoundary } from '@/components/ErrorBoundary';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <ErrorBoundary>
          {children}
        </ErrorBoundary>
      </body>
    </html>
  );
}
```

### Frontend Error Handling Utilities
```typescript
// apps/web/src/utils/errorHandling.ts
import { toast } from 'sonner';

export function handleApiError(error: any) {
  let message = 'An unexpected error occurred';

  if (error?.response?.data?.message) {
    message = error.response.data.message;
  } else if (error?.message) {
    message = error.message;
  }

  // Network error
  if (isNetworkError(error)) {
    message = 'Network error. Please check your connection.';
  }

  toast.error(message);
}

export function isNetworkError(error: any): boolean {
  return (
    !error?.response &&
    (error?.code === 'ERR_NETWORK' || error?.message?.includes('Network'))
  );
}

export function getErrorMessage(error: any): string {
  if (error?.response?.data?.message) {
    return error.response.data.message;
  }
  if (error?.message) {
    return error.message;
  }
  return 'An unexpected error occurred';
}
```

**Usage:**
```typescript
import { handleApiError } from '@/utils/errorHandling';

try {
  await fetch('/api/characters', { method: 'POST', body: JSON.stringify(data) });
} catch (error) {
  handleApiError(error);
}
```

### Sentry Integration (Optional)
**[Source: Sentry documentation]**

```bash
pnpm add @sentry/node @sentry/nextjs
```

**Backend:**
```typescript
// apps/api/src/lib/sentry.ts
import * as Sentry from '@sentry/node';

if (process.env.SENTRY_DSN) {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV,
    tracesSampleRate: 0.1,
  });
}

export { Sentry };
```

**Register in Express:**
```typescript
// apps/api/src/server.ts
import { Sentry } from './lib/sentry';

// Request handler (before routes)
app.use(Sentry.Handlers.requestHandler());

// ... routes

// Error handler (before global error handler)
app.use(Sentry.Handlers.errorHandler());
```

**Frontend:**
```typescript
// apps/web/src/app/layout.tsx
import * as Sentry from '@sentry/nextjs';

if (process.env.NEXT_PUBLIC_SENTRY_DSN) {
  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    environment: process.env.NODE_ENV,
    tracesSampleRate: 0.1,
  });
}
```

### Log Critical Events
```typescript
// apps/api/src/controllers/auth.controller.ts (example)
import { logger } from '../lib/logger';

export const authController = {
  async login(req: Request, res: Response, next: NextFunction) {
    try {
      const { email, password } = req.body;

      const user = await prisma.user.findUnique({ where: { email } });

      if (!user || !(await bcrypt.compare(password, user.passwordHash))) {
        logger.warn('Failed login attempt', { email, ip: req.ip });
        throw new UnauthorizedError('Invalid credentials');
      }

      logger.info('User logged in', { userId: user.id, email: user.email });

      // ... create session
    } catch (error) {
      next(error);
    }
  },

  async logout(req: Request, res: Response, next: NextFunction) {
    const userId = req.user!.id;
    logger.info('User logged out', { userId });
    // ... clear session
  },
};
```

### Admin Log Viewer
```typescript
// apps/api/src/controllers/adminLogs.controller.ts
import { Request, Response, NextFunction } from 'express';
import fs from 'fs/promises';
import path from 'path';

export const adminLogsController = {
  async getLogs(req: Request, res: Response, next: NextFunction) {
    try {
      const { level = 'error', limit = 100 } = req.query;

      const logFile =
        level === 'error' ? 'logs/error.log' : 'logs/combined.log';

      const logPath = path.join(process.cwd(), logFile);

      // Read log file
      const content = await fs.readFile(logPath, 'utf-8');
      const lines = content.split('\n').filter(Boolean);

      // Parse JSON logs
      const logs = lines
        .slice(-Number(limit))
        .map((line) => {
          try {
            return JSON.parse(line);
          } catch {
            return { message: line };
          }
        })
        .reverse();

      res.json({ logs });
    } catch (error) {
      next(error);
    }
  },
};
```

**Route:**
```typescript
// apps/api/src/routes/admin.routes.ts
import { adminLogsController } from '../controllers/adminLogs.controller';

router.get('/logs', authenticate, requireAdmin, adminLogsController.getLogs);
```

### Environment Variables
```bash
# .env (backend)
NODE_ENV=production
SENTRY_DSN=https://xxx@sentry.io/xxx

# .env.local (frontend)
NEXT_PUBLIC_SENTRY_DSN=https://xxx@sentry.io/xxx
```

### Testing

**Test scenarios:**
- Trigger 404 error, verify logged to error.log
- Trigger 500 error, verify logged with stack trace
- Trigger validation error, verify 400 response
- Check error response format: `{ error, message, statusCode }`
- Frontend error boundary catches render errors
- Toast notifications show user-friendly messages
- Request logging includes userId, requestId, duration
- Log rotation creates new files daily
- Old logs deleted after 14 days
- Sentry receives errors (if configured)
- Admin log viewer returns recent logs
- Context logger includes userId/tableId in logs
- Critical events logged (login, logout, subscription changes)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
