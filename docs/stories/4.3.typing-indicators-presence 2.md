# Story 4.3: Typing Indicators & Presence System

## Status
Draft

## Story
**As a** Table Member,
**I want** to see who is currently online and when someone is typing,
**so that** I know who is active and engaged in the conversation.

## Acceptance Criteria
1. Member list shows online status (green dot) for connected members
2. Member list shows "typing..." indicator when someone is typing
3. Typing indicator appears below chat input: "Alice is typing..."
4. Typing indicator clears after 3 seconds of inactivity
5. Multiple users typing shows: "Alice, Bob, and Carol are typing..."
6. Online status updates in real-time via Socket.io
7. User status changes to offline after disconnect or 30s timeout
8. Presence persists across page refreshes (stored in database)

## Tasks / Subtasks

- [ ] Implement online status tracking (AC: 1, 6)
  - [ ] Emit `user:online` event when socket connects
  - [ ] Server updates user status to "online" in database
  - [ ] Broadcast `presence:update` to relevant table rooms
  - [ ] Client updates member list with online status
  - [ ] Show green dot for online, gray for offline

- [ ] Implement offline status tracking (AC: 7)
  - [ ] Emit `user:offline` event on socket disconnect
  - [ ] Server updates user status to "offline" in database
  - [ ] Set 30-second timeout before marking offline
  - [ ] Broadcast `presence:update` to table rooms
  - [ ] Client updates member list

- [ ] Create typing indicator system (AC: 2, 3, 4)
  - [ ] Emit `typing:start` when user types in chat input
  - [ ] Debounce emit (only emit every 500ms)
  - [ ] Server broadcasts `typing:start` to table room
  - [ ] Client shows "Alice is typing..." below chat
  - [ ] Auto-hide after 3 seconds if no `typing:stop` received

- [ ] Handle typing stop event (AC: 4)
  - [ ] Emit `typing:stop` when user stops typing (3s idle)
  - [ ] Emit `typing:stop` when message is sent
  - [ ] Server broadcasts `typing:stop` to table room
  - [ ] Client removes typing indicator

- [ ] Handle multiple users typing (AC: 5)
  - [ ] Track list of currently typing users
  - [ ] Format display: "Alice is typing..."
  - [ ] Format for 2 users: "Alice and Bob are typing..."
  - [ ] Format for 3+: "Alice, Bob, and Carol are typing..."
  - [ ] Limit display to first 3 users, show "+2 more" if needed

- [ ] Create presence database tracking (AC: 8)
  - [ ] Add `onlineStatus` and `lastSeenAt` to User model
  - [ ] Update on `user:online` event
  - [ ] Update on `user:offline` event
  - [ ] Query on page load to show initial presence

- [ ] Optimize presence updates (AC: 6)
  - [ ] Only broadcast to users in same table(s)
  - [ ] Throttle status updates (max 1 per 5 seconds)
  - [ ] Use Redis for presence state (optional for MVP)
  - [ ] Handle rapid connect/disconnect gracefully

- [ ] Add typing indicator UI component (AC: 3)
  - [ ] Position below chat input area
  - [ ] Show animated dots: "Alice is typing..."
  - [ ] Use gray text color
  - [ ] Fade in/out animation (200ms)
  - [ ] Limit height to 1 line

- [ ] Add presence indicator to member list (AC: 1)
  - [ ] Green dot (bg-green-neon) for online
  - [ ] Gray dot (bg-gray-600) for offline
  - [ ] Position dot on avatar (bottom-right corner)
  - [ ] Add tooltip: "Online" or "Last seen 5m ago"

- [ ] Handle edge cases
  - [ ] Prevent spam (throttle typing events)
  - [ ] Handle rapid reconnects
  - [ ] Clear typing indicator on disconnect
  - [ ] Sync presence state on reconnect

## Dev Notes

### Presence System Flow
**[Source: Architecture Section 5.3.2 - Presence Events]**

```
┌──────────────────────────────────────────────────────────┐
│ CLIENT A (Alice)                                         │
│                                                          │
│ 1. Socket connects                                      │
│ 2. Emits: user:online { userId: "clxxx" }               │
│                                                          │
│ 3. Types in chat input                                  │
│ 4. Emits: typing:start { tableId, userId }              │
│                                                          │
│ 5. Stops typing (3s idle)                               │
│ 6. Emits: typing:stop { tableId, userId }               │
└──────────────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────────────┐
│ SERVER                                                   │
│                                                          │
│ 1. Receives user:online                                 │
│ 2. Updates DB: user.onlineStatus = "online"             │
│ 3. Broadcasts: presence:update to all table rooms       │
│                                                          │
│ 4. Receives typing:start                                │
│ 5. Broadcasts to table:clxxx room                       │
│                                                          │
│ 6. Receives typing:stop                                 │
│ 7. Broadcasts to table:clxxx room                       │
└──────────────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────────────┐
│ CLIENTS B, C, D (Bob, Carol, Dave)                       │
│                                                          │
│ 1. Receive: presence:update { userId, status: "online" }│
│ 2. Update member list: show green dot for Alice         │
│                                                          │
│ 3. Receive: typing:start { userId: "clxxx" }            │
│ 4. Show: "Alice is typing..."                           │
│                                                          │
│ 5. Receive: typing:stop { userId: "clxxx" }             │
│ 6. Hide typing indicator for Alice                      │
└──────────────────────────────────────────────────────────┘
```

### Socket.io Presence Events
**[Source: Architecture Section 5.3.2]**

```typescript
// apps/api/src/socket/presence.socket.ts
import { Server as SocketIOServer, Socket } from 'socket.io';
import { prisma } from '@iarpg/db';

export function setupPresenceSocket(io: SocketIOServer) {
  io.on('connection', (socket: Socket) => {
    const userId = socket.data.userId;

    // User comes online
    socket.on('user:online', async () => {
      if (!userId) return;

      // Update database
      await prisma.user.update({
        where: { id: userId },
        data: {
          onlineStatus: 'online',
          lastSeenAt: new Date(),
        },
      });

      // Get user's active tables
      const memberships = await prisma.tableMember.findMany({
        where: { userId },
        select: { tableId: true },
      });

      // Broadcast to all user's tables
      memberships.forEach(({ tableId }) => {
        io.to(`table:${tableId}`).emit('presence:update', {
          userId,
          status: 'online',
        });
      });
    });

    // User goes offline (with timeout)
    socket.on('disconnect', async () => {
      if (!userId) return;

      // Wait 30 seconds before marking offline (reconnection grace period)
      setTimeout(async () => {
        // Check if user has any active sockets
        const userSockets = await io.in(`user:${userId}`).allSockets();
        if (userSockets.size > 0) return; // Still connected elsewhere

        await prisma.user.update({
          where: { id: userId },
          data: {
            onlineStatus: 'offline',
            lastSeenAt: new Date(),
          },
        });

        const memberships = await prisma.tableMember.findMany({
          where: { userId },
          select: { tableId: true },
        });

        memberships.forEach(({ tableId }) => {
          io.to(`table:${tableId}`).emit('presence:update', {
            userId,
            status: 'offline',
          });
        });
      }, 30000); // 30-second timeout
    });

    // Typing indicators
    socket.on('typing:start', ({ tableId }: { tableId: string }) => {
      socket.to(`table:${tableId}`).emit('typing:start', {
        userId,
        username: socket.data.username,
      });
    });

    socket.on('typing:stop', ({ tableId }: { tableId: string }) => {
      socket.to(`table:${tableId}`).emit('typing:stop', { userId });
    });
  });
}
```

### Typing Indicator Hook
```typescript
// apps/web/src/hooks/useTypingIndicator.ts
import { useEffect, useState, useCallback } from 'react';
import { useSocketContext } from '@/contexts/SocketContext';
import { debounce } from 'lodash';

export function useTypingIndicator(tableId: string) {
  const { socket } = useSocketContext();
  const [isTyping, setIsTyping] = useState(false);
  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());

  // Debounced emit typing:start (throttle to max 1 per 500ms)
  const emitTypingStart = useCallback(
    debounce(() => {
      if (!socket) return;
      socket.emit('typing:start', { tableId });
    }, 500),
    [socket, tableId]
  );

  // Emit typing:stop after 3 seconds of inactivity
  const emitTypingStop = useCallback(
    debounce(() => {
      if (!socket) return;
      socket.emit('typing:stop', { tableId });
      setIsTyping(false);
    }, 3000),
    [socket, tableId]
  );

  // Call this when user types
  const handleTyping = () => {
    if (!isTyping) {
      setIsTyping(true);
      emitTypingStart();
    }
    emitTypingStop(); // Reset 3s timeout
  };

  // Call this when user sends message
  const handleStopTyping = () => {
    if (!socket) return;
    socket.emit('typing:stop', { tableId });
    setIsTyping(false);
    emitTypingStart.cancel();
    emitTypingStop.cancel();
  };

  // Listen for typing events from others
  useEffect(() => {
    if (!socket) return;

    socket.on('typing:start', ({ userId, username }: { userId: string; username: string }) => {
      setTypingUsers((prev) => new Set([...prev, username]));

      // Auto-remove after 3 seconds (in case typing:stop is missed)
      setTimeout(() => {
        setTypingUsers((prev) => {
          const updated = new Set(prev);
          updated.delete(username);
          return updated;
        });
      }, 3000);
    });

    socket.on('typing:stop', ({ userId }: { userId: string }) => {
      setTypingUsers((prev) => {
        const updated = new Set(prev);
        // Remove by userId (need to map userId to username)
        return updated;
      });
    });

    return () => {
      socket.off('typing:start');
      socket.off('typing:stop');
    };
  }, [socket]);

  return {
    handleTyping,
    handleStopTyping,
    typingUsers: Array.from(typingUsers),
  };
}
```

### Typing Indicator Component
```typescript
interface TypingIndicatorProps {
  typingUsers: string[];
}

export function TypingIndicator({ typingUsers }: TypingIndicatorProps) {
  if (typingUsers.length === 0) return null;

  const formatTypingUsers = () => {
    if (typingUsers.length === 1) {
      return `${typingUsers[0]} is typing`;
    } else if (typingUsers.length === 2) {
      return `${typingUsers[0]} and ${typingUsers[1]} are typing`;
    } else if (typingUsers.length === 3) {
      return `${typingUsers[0]}, ${typingUsers[1]}, and ${typingUsers[2]} are typing`;
    } else {
      return `${typingUsers[0]}, ${typingUsers[1]}, and ${typingUsers.length - 2} others are typing`;
    }
  };

  return (
    <div className="px-4 py-2 text-small text-gray-400 italic animate-fade-in">
      {formatTypingUsers()}
      <span className="animate-pulse">...</span>
    </div>
  );
}
```

### Chat Input with Typing Indicator
```typescript
export function ChatInput({ tableId }: { tableId: string }) {
  const [content, setContent] = useState('');
  const { handleTyping, handleStopTyping, typingUsers } = useTypingIndicator(tableId);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
    handleTyping();
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim()) return;

    // Send message
    await sendMessage(content);

    setContent('');
    handleStopTyping(); // Clear typing indicator
  };

  return (
    <div>
      <TypingIndicator typingUsers={typingUsers} />

      <form onSubmit={handleSubmit} className="p-4 border-t border-gray-800">
        <div className="flex gap-2">
          <Textarea
            value={content}
            onChange={handleChange}
            placeholder="Type a message..."
          />
          <Button type="submit">Send</Button>
        </div>
      </form>
    </div>
  );
}
```

### Presence Update Hook
```typescript
// apps/web/src/hooks/usePresence.ts
import { useEffect, useState } from 'react';
import { useSocketContext } from '@/contexts/SocketContext';

interface PresenceState {
  [userId: string]: 'online' | 'offline';
}

export function usePresence(tableId: string) {
  const { socket } = useSocketContext();
  const [presence, setPresence] = useState<PresenceState>({});

  useEffect(() => {
    if (!socket) return;

    // Emit user:online when socket connects
    socket.emit('user:online');

    // Listen for presence updates
    socket.on('presence:update', ({ userId, status }: { userId: string; status: string }) => {
      setPresence((prev) => ({
        ...prev,
        [userId]: status as 'online' | 'offline',
      }));
    });

    return () => {
      socket.off('presence:update');
    };
  }, [socket]);

  return presence;
}
```

### Member List with Presence
```typescript
export function MemberList({ members, tableId }: MemberListProps) {
  const presence = usePresence(tableId);

  return (
    <div className="p-4">
      <h2 className="text-h4 font-bold mb-4">Members</h2>

      <div className="space-y-3">
        {members.map((member) => {
          const isOnline = presence[member.userId] === 'online';

          return (
            <div key={member.id} className="flex items-center gap-3">
              <div className="relative">
                <Avatar className="h-10 w-10">
                  <AvatarImage src={member.user.avatar} />
                  <AvatarFallback>{member.user.username[0]}</AvatarFallback>
                </Avatar>

                {/* Presence indicator */}
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <span
                        className={`absolute bottom-0 right-0 h-3 w-3 rounded-full border-2 border-black ${
                          isOnline ? 'bg-green-neon' : 'bg-gray-600'
                        }`}
                      />
                    </TooltipTrigger>
                    <TooltipContent>
                      {isOnline ? 'Online' : `Last seen ${formatLastSeen(member.user.lastSeenAt)}`}
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>

              <div className="flex-1">
                <p className="font-medium">{member.user.username}</p>
                <p className="text-small text-gray-400">
                  {member.character?.name} • {member.character?.class}
                </p>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

### Database Schema Update
**[Source: Architecture Section 4.1 - User Model]**

```prisma
model User {
  id           String   @id @default(cuid())
  email        String   @unique
  username     String   @unique
  onlineStatus String   @default("offline") // online, offline, away
  lastSeenAt   DateTime @default(now())
  // ... other fields
}
```

### Migration
```sql
-- Add presence fields to User table
ALTER TABLE "User"
ADD COLUMN "onlineStatus" TEXT DEFAULT 'offline',
ADD COLUMN "lastSeenAt" TIMESTAMP DEFAULT NOW();

CREATE INDEX "User_onlineStatus_idx" ON "User"("onlineStatus");
```

### Optimize with Redis (Optional)
```typescript
// For high-scale, use Redis for presence instead of database
import { Redis } from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// Set user online (with 5-minute TTL)
await redis.setex(`presence:${userId}`, 300, 'online');

// Check user presence
const status = await redis.get(`presence:${userId}`);
const isOnline = status === 'online';

// Extend TTL on activity
socket.on('typing:start', async () => {
  await redis.expire(`presence:${userId}`, 300);
});
```

### Helper Functions
```typescript
// Format last seen timestamp
function formatLastSeen(lastSeenAt: Date | string): string {
  const d = new Date(lastSeenAt);
  const now = new Date();
  const diffMs = now.getTime() - d.getTime();
  const diffMins = Math.floor(diffMs / 60000);

  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return `${diffMins}m ago`;

  const diffHours = Math.floor(diffMins / 60);
  if (diffHours < 24) return `${diffHours}h ago`;

  const diffDays = Math.floor(diffHours / 24);
  return `${diffDays}d ago`;
}
```

### Testing

**Test scenarios:**
- User status changes to online when socket connects
- User status changes to offline after disconnect (30s timeout)
- Green dot shows for online users in member list
- Typing indicator appears when user types
- Typing indicator disappears after 3 seconds of inactivity
- Typing indicator clears when message is sent
- Multiple users typing shows correct format
- Presence updates in real-time across multiple clients
- Reconnect updates presence correctly
- Last seen timestamp displays correctly
- Typing events are throttled (max 1 per 500ms)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
