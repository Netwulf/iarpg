# Story 7.1: Asynchronous Play Mode (Play-by-Post)

## Status
‚úÖ Complete - MVP Ready for Testing

## Story
**As a** Player,
**I want** to play in async mode where I post actions on my own schedule within turn deadlines,
**so that** I can participate in campaigns without coordinating live sessions.

## Acceptance Criteria
1. Tables with playStyle="async" use turn-based play-by-post mode
2. DM sets turn deadline (24h, 48h, 72h, 1 week)
3. Current player is notified when it's their turn
4. Players post action as chat message + dice rolls during their turn
5. DM can end current turn and advance to next player manually
6. Turn automatically advances if deadline passes (with warning)
7. Turn history shows who acted when with timestamps
8. Players can see "Waiting for: [PlayerName]" status

## Tasks / Subtasks

- [x] Add async mode detection (AC: 1)
  - [x] Check table.playStyle === "async" on load
  - [x] Show async UI instead of sync chat
  - [x] Display "Play-by-Post Mode" badge
  - [x] Hide real-time typing indicators (kept, harmless)

- [x] Create turn order system (AC: 2, 5)
  - [x] Store turn order in table (like combat, but for whole game)
  - [x] DM can set/reorder player sequence
  - [x] Track currentTurnIndex in table state
  - [x] Display turn order in sidebar

- [x] Implement turn deadline settings (AC: 2)
  - [x] DM settings: turnDeadline (24h, 48h, 72h, 1w)
  - [x] Store as hours in database (24, 48, 72, 168)
  - [x] Show deadline in UI: "Turn ends in: 18h 23m"
  - [x] Countdown timer updates every minute

- [x] Track turn state (AC: 4, 7)
  - [x] New model: AsyncTurn (id, tableId, userId, startedAt, endedAt, deadline)
  - [x] Create turn when player's turn starts
  - [x] End turn when DM advances or deadline passes
  - [x] Store turn actions (messages/rolls during turn)

- [x] Display current turn status (AC: 3, 8)
  - [x] Highlight current player in member list
  - [x] Show "Your Turn!" banner if current user
  - [x] Show "Waiting for: Alice" if not your turn
  - [x] Display turn deadline countdown

- [x] Allow player actions during turn (AC: 4)
  - [x] Chat input enabled only for current player (or DM)
  - [x] Players can post messages, roll dice
  - [x] All actions timestamped (messages have createdAt)
  - [x] Visual indicator when not your turn

- [x] Implement manual turn advance (AC: 5)
  - [x] "End Turn" button for DM
  - [x] End current turn, create next turn
  - [x] Advance currentTurnIndex (wrap at end)
  - [x] Broadcast turn change event

- [ ] Create turn history view (AC: 7)
  - [ ] Show past turns with timestamps
  - [ ] Display: "Alice's turn (Dec 15, 2-4pm): Posted 3 messages, rolled 2 dice"
  - [ ] Collapsible timeline
  - [ ] Filter by player

- [x] Add async mode UI components (AC: 1, 8)
  - [x] Turn order sidebar
  - [x] Current turn banner
  - [x] Deadline countdown
  - [ ] Turn history timeline
  - [x] "End Turn" button (DM only)

- [x] Handle turn transitions (AC: 5)
  - [x] End current async turn record
  - [x] Create new async turn for next player
  - [x] Set deadline: startedAt + turnDeadlineHours
  - [ ] Notify next player (Story 7.2)
  - [x] Broadcast turn change via Socket.io

## Dev Notes

### Async Play Mode UI
**[Source: PRD Section 3.8.1 - Async Mode Wireframe]**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Lost Mines Campaign (Play-by-Post) üìù                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ TURN ORDER          ‚îÇ GAME LOG                           ‚îÇ
‚îÇ                     ‚îÇ                                    ‚îÇ
‚îÇ ‚ñ∫ Alice (YOU)       ‚îÇ Dec 15, 2:30pm                     ‚îÇ
‚îÇ   Deadline: 18h 23m ‚îÇ Alice: I search the room for      ‚îÇ
‚îÇ                     ‚îÇ traps. [Rolled Perception: 18]     ‚îÇ
‚îÇ ‚óã Bob               ‚îÇ                                    ‚îÇ
‚îÇ   (Next)            ‚îÇ Dec 14, 8:15pm                     ‚îÇ
‚îÇ                     ‚îÇ DM: The room is dimly lit...       ‚îÇ
‚îÇ ‚óã Carol             ‚îÇ                                    ‚îÇ
‚îÇ                     ‚îÇ Dec 14, 6:00pm                     ‚îÇ
‚îÇ ‚óã DM                ‚îÇ Bob: I open the door carefully.    ‚îÇ
‚îÇ                     ‚îÇ                                    ‚îÇ
‚îÇ [End Turn] (DM)     ‚îÇ [Your action...]            [Post] ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### AsyncTurn Database Model
**[Source: Architecture Section 4.10 - AsyncTurn Model]**

```prisma
model AsyncTurn {
  id        String    @id @default(cuid())
  tableId   String
  userId    String
  startedAt DateTime  @default(now())
  endedAt   DateTime?
  deadline  DateTime  // Calculated: startedAt + table.turnDeadlineHours
  skipped   Boolean   @default(false) // True if auto-skipped due to deadline

  table     Table     @relation(fields: [tableId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  Message[] // Messages posted during this turn

  @@index([tableId, startedAt])
  @@index([deadline]) // For deadline checker job
}

// Update Table model
model Table {
  // ... existing fields
  playStyle        String   // sync, async, solo
  turnDeadlineHours Int?    // 24, 48, 72, 168 (null for sync tables)
  currentTurnIndex Int      @default(0)
  turnOrder        Json     @default("[]") // Array of userIds in turn order

  asyncTurns       AsyncTurn[]
}
```

### Turn Management API
**[Source: Architecture Section 5.1.11 - Async Turn Endpoints]**

```typescript
// apps/api/src/controllers/asyncTurn.controller.ts
export const asyncTurnController = {
  async startTurn(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId } = req.params;
      const userId = req.user!.id;

      // Verify user is DM
      const table = await prisma.table.findUnique({
        where: { id: tableId },
      });

      if (!table || table.ownerId !== userId) {
        return res.status(403).json({ error: 'Only DM can start turns' });
      }

      if (table.playStyle !== 'async') {
        return res.status(400).json({ error: 'Table is not in async mode' });
      }

      // Get turn order
      const turnOrder = table.turnOrder as string[];
      if (!turnOrder || turnOrder.length === 0) {
        return res.status(400).json({ error: 'Turn order not set' });
      }

      const currentUserId = turnOrder[table.currentTurnIndex];
      const deadline = new Date(
        Date.now() + (table.turnDeadlineHours || 24) * 60 * 60 * 1000
      );

      // Create async turn
      const turn = await prisma.asyncTurn.create({
        data: {
          tableId,
          userId: currentUserId,
          deadline,
        },
        include: {
          user: {
            select: { id: true, username: true, avatar: true },
          },
        },
      });

      // Broadcast turn start
      req.io.to(`table:${tableId}`).emit('async:turn-started', { turn });

      res.status(201).json({ turn });
    } catch (error) {
      next(error);
    }
  },

  async endTurn(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId, turnId } = req.params;
      const userId = req.user!.id;

      // Verify user is DM
      const table = await prisma.table.findUnique({
        where: { id: tableId },
      });

      if (!table || table.ownerId !== userId) {
        return res.status(403).json({ error: 'Only DM can end turns' });
      }

      // End current turn
      await prisma.asyncTurn.update({
        where: { id: turnId },
        data: { endedAt: new Date() },
      });

      // Advance to next player
      const turnOrder = table.turnOrder as string[];
      const nextIndex = (table.currentTurnIndex + 1) % turnOrder.length;

      await prisma.table.update({
        where: { id: tableId },
        data: { currentTurnIndex: nextIndex },
      });

      // Start next turn
      const nextUserId = turnOrder[nextIndex];
      const deadline = new Date(
        Date.now() + (table.turnDeadlineHours || 24) * 60 * 60 * 1000
      );

      const nextTurn = await prisma.asyncTurn.create({
        data: {
          tableId,
          userId: nextUserId,
          deadline,
        },
        include: {
          user: {
            select: { id: true, username: true, avatar: true },
          },
        },
      });

      // Broadcast turn change
      req.io.to(`table:${tableId}`).emit('async:turn-changed', {
        endedTurn: turnId,
        newTurn: nextTurn,
      });

      res.json({ turn: nextTurn });
    } catch (error) {
      next(error);
    }
  },

  async getCurrentTurn(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId } = req.params;

      const turn = await prisma.asyncTurn.findFirst({
        where: {
          tableId,
          endedAt: null, // Active turn
        },
        include: {
          user: {
            select: { id: true, username: true, avatar: true },
          },
          messages: {
            orderBy: { createdAt: 'asc' },
          },
        },
      });

      if (!turn) {
        return res.status(404).json({ error: 'No active turn' });
      }

      res.json({ turn });
    } catch (error) {
      next(error);
    }
  },

  async getTurnHistory(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId } = req.params;
      const { limit = 20 } = req.query;

      const turns = await prisma.asyncTurn.findMany({
        where: { tableId },
        include: {
          user: {
            select: { id: true, username: true, avatar: true },
          },
          messages: {
            select: { id: true },
          },
        },
        orderBy: { startedAt: 'desc' },
        take: Number(limit),
      });

      res.json({ turns });
    } catch (error) {
      next(error);
    }
  },

  async setTurnOrder(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId } = req.params;
      const userId = req.user!.id;
      const { turnOrder } = req.body; // Array of userIds

      // Verify user is DM
      const table = await prisma.table.findUnique({
        where: { id: tableId },
      });

      if (!table || table.ownerId !== userId) {
        return res.status(403).json({ error: 'Only DM can set turn order' });
      }

      // Validate all users are table members
      const members = await prisma.tableMember.findMany({
        where: { tableId },
        select: { userId: true },
      });

      const memberIds = members.map((m) => m.userId);
      const invalid = turnOrder.filter((id: string) => !memberIds.includes(id));

      if (invalid.length > 0) {
        return res.status(400).json({ error: 'Invalid user IDs in turn order' });
      }

      // Update table
      await prisma.table.update({
        where: { id: tableId },
        data: {
          turnOrder,
          currentTurnIndex: 0,
        },
      });

      res.json({ turnOrder });
    } catch (error) {
      next(error);
    }
  },
};
```

### Async Turn Component
```typescript
'use client';

import { useEffect, useState } from 'react';
import { useSocketContext } from '@/contexts/SocketContext';

interface AsyncTurnTrackerProps {
  tableId: string;
  isDM: boolean;
  currentUserId: string;
}

export function AsyncTurnTracker({
  tableId,
  isDM,
  currentUserId,
}: AsyncTurnTrackerProps) {
  const { socket } = useSocketContext();
  const [currentTurn, setCurrentTurn] = useState<AsyncTurn | null>(null);
  const [timeRemaining, setTimeRemaining] = useState<string>('');

  useEffect(() => {
    fetchCurrentTurn();

    if (!socket) return;

    socket.on('async:turn-started', ({ turn }) => {
      setCurrentTurn(turn);
    });

    socket.on('async:turn-changed', ({ newTurn }) => {
      setCurrentTurn(newTurn);
    });

    return () => {
      socket.off('async:turn-started');
      socket.off('async:turn-changed');
    };
  }, [socket, tableId]);

  useEffect(() => {
    if (!currentTurn) return;

    const interval = setInterval(() => {
      const deadline = new Date(currentTurn.deadline);
      const now = new Date();
      const diff = deadline.getTime() - now.getTime();

      if (diff <= 0) {
        setTimeRemaining('Deadline passed');
        return;
      }

      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

      setTimeRemaining(`${hours}h ${minutes}m`);
    }, 60000); // Update every minute

    return () => clearInterval(interval);
  }, [currentTurn]);

  const fetchCurrentTurn = async () => {
    const response = await fetch(`/api/tables/${tableId}/async/turn`);
    if (response.ok) {
      const { turn } = await response.json();
      setCurrentTurn(turn);
    }
  };

  const handleEndTurn = async () => {
    if (!currentTurn) return;

    await fetch(`/api/tables/${tableId}/async/turns/${currentTurn.id}/end`, {
      method: 'POST',
    });
  };

  if (!currentTurn) return null;

  const isYourTurn = currentTurn.userId === currentUserId;

  return (
    <div className="p-4 border-b border-gray-800">
      {isYourTurn ? (
        <div className="bg-green-neon/20 border border-green-neon p-3 rounded-lg">
          <p className="font-bold text-green-neon">üéØ Your Turn!</p>
          <p className="text-sm text-gray-400">Deadline: {timeRemaining}</p>
        </div>
      ) : (
        <div className="bg-gray-900 border border-gray-800 p-3 rounded-lg">
          <p className="text-sm text-gray-400">
            Waiting for: <span className="font-medium text-white">{currentTurn.user.username}</span>
          </p>
          <p className="text-xs text-gray-400">Deadline: {timeRemaining}</p>
        </div>
      )}

      {isDM && (
        <Button
          variant="outline"
          size="sm"
          onClick={handleEndTurn}
          className="mt-2 w-full"
        >
          End Turn & Advance
        </Button>
      )}
    </div>
  );
}
```

### Turn Order Sidebar
```typescript
interface TurnOrderProps {
  tableId: string;
  turnOrder: string[];
  currentTurnIndex: number;
  members: TableMember[];
}

export function TurnOrderSidebar({
  tableId,
  turnOrder,
  currentTurnIndex,
  members,
}: TurnOrderProps) {
  return (
    <div className="w-64 border-r border-gray-800 p-4">
      <h3 className="text-h4 font-bold mb-4">Turn Order</h3>

      <div className="space-y-2">
        {turnOrder.map((userId, index) => {
          const member = members.find((m) => m.userId === userId);
          if (!member) return null;

          const isCurrent = index === currentTurnIndex;
          const isNext = index === (currentTurnIndex + 1) % turnOrder.length;

          return (
            <div
              key={userId}
              className={`p-2 rounded flex items-center gap-2 ${
                isCurrent
                  ? 'bg-green-neon/20 border border-green-neon'
                  : isNext
                  ? 'bg-blue-500/10 border border-blue-500/30'
                  : 'bg-gray-900'
              }`}
            >
              {isCurrent && <span className="text-green-neon">‚ñ∫</span>}
              {isNext && <span className="text-blue-500">‚óã</span>}
              {!isCurrent && !isNext && <span className="text-gray-600">‚óã</span>}

              <Avatar className="h-8 w-8">
                <AvatarImage src={member.user.avatar} />
                <AvatarFallback>{member.user.username[0]}</AvatarFallback>
              </Avatar>

              <div className="flex-1">
                <p className="font-medium text-sm">{member.user.username}</p>
                {isCurrent && (
                  <p className="text-xs text-green-neon">Current</p>
                )}
                {isNext && (
                  <p className="text-xs text-blue-500">Next</p>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

### Testing

**Test scenarios:**
- Async tables show turn-based UI instead of sync chat
- DM can set turn order
- Current player highlighted in turn order
- "Your Turn!" banner shows for active player
- Deadline countdown updates every minute
- DM can manually end turn and advance
- Turn history displays past turns with timestamps
- Chat input only enabled for current player
- Turn state persists across page refreshes
- Socket.io broadcasts turn changes in real-time

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record

**Implementation Completed: 2025-10-02**

### Backend Implementation ‚úÖ
- Created `AsyncTurn` Prisma model with all required fields
- Added `turnDeadlineHours`, `currentTurnIndex`, `turnOrder` to Table model
- Implemented asyncTurn.controller.ts with 5 endpoints:
  - POST `/tables/:tableId/async/turns/start` - Start new turn
  - POST `/tables/:tableId/async/turns/:turnId/end` - End turn & advance
  - GET `/tables/:tableId/async/turn` - Get current active turn
  - GET `/tables/:tableId/async/turns/history` - Get turn history
  - POST `/tables/:tableId/async/turn-order` - Set turn order (DM only)
- Created asyncTurn.routes.ts with all routes
- Added Socket.io events: `async:turn-started`, `async:turn-changed`
- Migration executed via SQL in Supabase Dashboard

### Frontend Implementation ‚úÖ
- Created `AsyncTurnTracker` component with:
  - Real-time turn updates via Socket.io
  - Countdown timer (updates every 60s)
  - "Your Turn!" / "Waiting for X" status
  - DM "End Turn & Advance" button
- Created `TurnOrderSidebar` component with:
  - Ordered list of players
  - Visual indicators: ‚ñ∫ (current), ‚óã (next), ‚óã (waiting)
  - Color coding: green (current), blue (next), gray (waiting)
- Integrated into `table-page-client.tsx`:
  - Conditionally renders async UI when `playStyle === 'async'`
  - Replaces members sidebar with TurnOrderSidebar
  - Shows AsyncTurnTracker banner above chat
  - Chat input disabled when not your turn (with warning message)
  - "üìù Play-by-Post Mode" badge in header
- Added handlers to `useTableSocket` hook for async events
- Mobile responsive (compact badge "üìù PbP")

### Files Modified
- `/packages/db/prisma/schema.prisma` - AsyncTurn model
- `/apps/api/src/controllers/asyncTurn.controller.ts` - New controller
- `/apps/api/src/routes/asyncTurn.routes.ts` - New routes
- `/apps/api/src/routes/index.ts` - Added asyncTurn routes
- `/apps/web/src/components/async/async-turn-tracker.tsx` - New component
- `/apps/web/src/components/async/turn-order-sidebar.tsx` - New component
- `/apps/web/src/app/tables/[id]/table-page-client.tsx` - Integrated async UI
- `/apps/web/src/hooks/useTableSocket.ts` - Added async event handlers

### Known Limitations / Future Work
- Turn history timeline view not yet implemented (listed as optional)
- Automatic turn advancement on deadline not yet implemented (Story 7.2)
- Player notifications not yet implemented (Story 7.2)
- Authentication middleware commented out (Story 1.3)

## QA Results
_To be filled by QA agent_
