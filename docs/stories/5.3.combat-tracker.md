# Story 5.3: Combat Tracker (Initiative & HP Management)

## Status
Draft

## Story
**As a** DM,
**I want** to track combat encounters with initiative order, HP management, and turn tracking,
**so that** I can run organized combat sessions for my players.

## Acceptance Criteria
1. DM can start combat encounter from table page
2. Combat tracker displays initiative order (highest to lowest)
3. Players can roll initiative (1d20 + DEX modifier) automatically
4. DM can manually adjust initiative values
5. Current turn is highlighted, with "Next Turn" button (DM only)
6. HP bars display for each combatant with current/max values
7. DM can adjust HP with +/- buttons or direct input
8. Combat ends when DM clicks "End Combat" button

## Tasks / Subtasks

- [ ] Create combat encounter modal (AC: 1)
  - [ ] "Start Combat" button in table page (DM only)
  - [ ] Modal shows table members + option to add NPCs
  - [ ] "Roll Initiative" button for each member
  - [ ] Auto-roll: 1d20 + character's initiative modifier
  - [ ] "Start Combat" confirms and creates encounter

- [ ] Create CombatEncounter database model (AC: 1)
  - [ ] Fields: id, tableId, state (active/ended), round, currentTurn
  - [ ] Relation to Combatant model
  - [ ] createdAt, endedAt timestamps

- [ ] Create Combatant database model (AC: 2, 6)
  - [ ] Fields: id, encounterId, characterId?, name, initiative, hp, maxHp, isNPC, position
  - [ ] Position in turn order (calculated from initiative)
  - [ ] Link to Character (nullable for NPCs)

- [ ] Implement initiative rolling (AC: 3)
  - [ ] Fetch character's DEX modifier from database
  - [ ] Roll 1d20 + DEX modifier
  - [ ] Save initiative value to Combatant
  - [ ] Sort combatants by initiative (descending)
  - [ ] Broadcast combat state update via Socket.io

- [ ] Create combat tracker UI panel (AC: 2)
  - [ ] Collapsible panel on right side of table page
  - [ ] Show only when combat is active
  - [ ] Display "Round X" at top
  - [ ] List all combatants in initiative order
  - [ ] Highlight current turn with green border

- [ ] Create combatant card component (AC: 5, 6)
  - [ ] Show avatar (character or NPC placeholder)
  - [ ] Display name + initiative value
  - [ ] HP bar with current/max display
  - [ ] +/- buttons for HP adjustment (DM only)
  - [ ] Highlight current turn with green-neon border

- [ ] Implement turn progression (AC: 5)
  - [ ] "Next Turn" button visible to DM
  - [ ] Advances currentTurn index
  - [ ] Wraps to 0 at end of round, increments round counter
  - [ ] Broadcasts turn change via Socket.io
  - [ ] All players see updated current turn

- [ ] Implement HP tracking (AC: 7)
  - [ ] +/- buttons adjust HP by 1 (hold for faster)
  - [ ] Direct input field for precise values
  - [ ] Clamp HP between 0 and maxHp
  - [ ] Show visual indicator when HP reaches 0 (red, "Unconscious")
  - [ ] Broadcast HP changes in real-time

- [ ] Create HP bar component (AC: 6)
  - [ ] Visual progress bar (green â†’ yellow â†’ red)
  - [ ] Color: green (>50%), yellow (25-50%), red (<25%)
  - [ ] Display: "42 / 50 HP"
  - [ ] Animate HP changes

- [ ] Implement end combat (AC: 8)
  - [ ] "End Combat" button (DM only)
  - [ ] Confirmation dialog
  - [ ] Set encounter state to "ended"
  - [ ] Hide combat tracker panel
  - [ ] Broadcast combat end event

- [ ] Add NPC combatants (AC: 2)
  - [ ] DM can add NPCs to combat
  - [ ] Manual input: name, initiative, HP, maxHP
  - [ ] NPCs saved as Combatant with isNPC=true
  - [ ] No character link required

- [ ] Broadcast combat events (AC: 2, 5, 7)
  - [ ] `combat:started` - New encounter created
  - [ ] `combat:updated` - Initiative or HP changed
  - [ ] `combat:turn-changed` - Current turn advanced
  - [ ] `combat:ended` - Combat encounter finished

## Dev Notes

### Combat Tracker UI Layout
**[Source: PRD Section 3.6.2 - Combat Tracker Wireframe]**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ COMBAT TRACKER                  â”‚
â”‚ Round 3                   [End] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ ðŸ‘‘ Alice (DM)          Init: â”‚ â”‚ â† Current turn (highlighted)
â”‚ â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 42/50 HP  â”‚ â”‚
â”‚ â”‚ [+] [-]                     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Bob (Fighter)          Init:â”‚ â”‚
â”‚ â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 38/42 HP  â”‚ â”‚
â”‚ â”‚ [+] [-]                     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Goblin (NPC)           Init:â”‚ â”‚
â”‚ â”‚ â–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 5/15 HP    â”‚ â”‚
â”‚ â”‚ [+] [-]                     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚
â”‚          [Next Turn] (DM only)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Prisma Schema Updates
**[Source: Architecture Section 4.7 - Combat Models]**

```prisma
model CombatEncounter {
  id          String      @id @default(cuid())
  tableId     String
  state       String      @default("active") // active, ended
  round       Int         @default(1)
  currentTurn Int         @default(0) // Index in sorted combatants
  createdAt   DateTime    @default(now())
  endedAt     DateTime?

  table       Table       @relation(fields: [tableId], references: [id], onDelete: Cascade)
  combatants  Combatant[]

  @@index([tableId, state])
}

model Combatant {
  id          String   @id @default(cuid())
  encounterId String
  characterId String?
  name        String
  initiative  Int
  hp          Int
  maxHp       Int
  isNPC       Boolean  @default(false)
  position    Int      // Calculated from initiative for sorting

  encounter   CombatEncounter @relation(fields: [encounterId], references: [id], onDelete: Cascade)
  character   Character?      @relation(fields: [characterId], references: [id], onDelete: SetNull)

  @@index([encounterId, position])
}
```

### Start Combat API Endpoint
**[Source: Architecture Section 5.1.7 - Combat Endpoints]**

```typescript
// POST /api/tables/:tableId/combat/start
export const combatController = {
  async start(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId } = req.params;
      const userId = req.user!.id;
      const { combatants } = req.body; // Array of { characterId?, name, initiative, hp, maxHp, isNPC }

      // Verify user is DM
      const table = await prisma.table.findUnique({
        where: { id: tableId },
      });

      if (!table || table.ownerId !== userId) {
        return res.status(403).json({ error: 'Only DM can start combat' });
      }

      // Check if combat already active
      const existingCombat = await prisma.combatEncounter.findFirst({
        where: { tableId, state: 'active' },
      });

      if (existingCombat) {
        return res.status(400).json({ error: 'Combat already in progress' });
      }

      // Sort combatants by initiative (descending)
      const sortedCombatants = combatants.sort((a, b) => b.initiative - a.initiative);

      // Create combat encounter
      const encounter = await prisma.combatEncounter.create({
        data: {
          tableId,
          combatants: {
            create: sortedCombatants.map((c, idx) => ({
              characterId: c.characterId,
              name: c.name,
              initiative: c.initiative,
              hp: c.hp,
              maxHp: c.maxHp,
              isNPC: c.isNPC || false,
              position: idx,
            })),
          },
        },
        include: {
          combatants: {
            include: {
              character: {
                select: { id: true, name: true, avatarUrl: true },
              },
            },
            orderBy: { position: 'asc' },
          },
        },
      });

      // Broadcast combat started
      req.io.to(`table:${tableId}`).emit('combat:started', { encounter });

      res.status(201).json({ encounter });
    } catch (error) {
      next(error);
    }
  },

  // PATCH /api/tables/:tableId/combat/:encounterId/next-turn
  async nextTurn(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId, encounterId } = req.params;
      const userId = req.user!.id;

      // Verify user is DM
      const table = await prisma.table.findUnique({
        where: { id: tableId },
      });

      if (!table || table.ownerId !== userId) {
        return res.status(403).json({ error: 'Only DM can advance turn' });
      }

      // Get encounter
      const encounter = await prisma.combatEncounter.findUnique({
        where: { id: encounterId },
        include: {
          combatants: {
            orderBy: { position: 'asc' },
          },
        },
      });

      if (!encounter) {
        return res.status(404).json({ error: 'Combat encounter not found' });
      }

      const nextTurn = encounter.currentTurn + 1;
      const isNewRound = nextTurn >= encounter.combatants.length;

      // Update encounter
      const updated = await prisma.combatEncounter.update({
        where: { id: encounterId },
        data: {
          currentTurn: isNewRound ? 0 : nextTurn,
          round: isNewRound ? encounter.round + 1 : encounter.round,
        },
        include: {
          combatants: {
            include: {
              character: {
                select: { id: true, name: true, avatarUrl: true },
              },
            },
            orderBy: { position: 'asc' },
          },
        },
      });

      // Broadcast turn change
      req.io.to(`table:${tableId}`).emit('combat:turn-changed', {
        encounter: updated,
        currentCombatant: updated.combatants[updated.currentTurn],
      });

      res.json({ encounter: updated });
    } catch (error) {
      next(error);
    }
  },

  // PATCH /api/tables/:tableId/combat/:encounterId/combatants/:combatantId/hp
  async updateHP(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId, encounterId, combatantId } = req.params;
      const userId = req.user!.id;
      const { hp } = req.body;

      // Verify user is DM
      const table = await prisma.table.findUnique({
        where: { id: tableId },
      });

      if (!table || table.ownerId !== userId) {
        return res.status(403).json({ error: 'Only DM can update HP' });
      }

      // Update combatant HP
      const combatant = await prisma.combatant.update({
        where: { id: combatantId },
        data: { hp: Math.max(0, hp) }, // Clamp to 0 minimum
      });

      // Broadcast HP update
      req.io.to(`table:${tableId}`).emit('combat:hp-updated', {
        combatantId,
        hp: combatant.hp,
      });

      res.json({ combatant });
    } catch (error) {
      next(error);
    }
  },

  // POST /api/tables/:tableId/combat/:encounterId/end
  async end(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId, encounterId } = req.params;
      const userId = req.user!.id;

      // Verify user is DM
      const table = await prisma.table.findUnique({
        where: { id: tableId },
      });

      if (!table || table.ownerId !== userId) {
        return res.status(403).json({ error: 'Only DM can end combat' });
      }

      // End combat
      const encounter = await prisma.combatEncounter.update({
        where: { id: encounterId },
        data: {
          state: 'ended',
          endedAt: new Date(),
        },
      });

      // Broadcast combat ended
      req.io.to(`table:${tableId}`).emit('combat:ended', { encounterId });

      res.json({ encounter });
    } catch (error) {
      next(error);
    }
  },
};
```

### Combat Tracker Component
```typescript
'use client';

import { useEffect, useState } from 'react';
import { useSocketContext } from '@/contexts/SocketContext';

interface CombatTrackerProps {
  tableId: string;
  isDM: boolean;
}

export function CombatTracker({ tableId, isDM }: CombatTrackerProps) {
  const { socket } = useSocketContext();
  const [encounter, setEncounter] = useState<CombatEncounter | null>(null);

  useEffect(() => {
    if (!socket) return;

    // Listen for combat events
    socket.on('combat:started', ({ encounter }) => {
      setEncounter(encounter);
    });

    socket.on('combat:turn-changed', ({ encounter }) => {
      setEncounter(encounter);
    });

    socket.on('combat:hp-updated', ({ combatantId, hp }) => {
      setEncounter((prev) => {
        if (!prev) return null;
        return {
          ...prev,
          combatants: prev.combatants.map((c) =>
            c.id === combatantId ? { ...c, hp } : c
          ),
        };
      });
    });

    socket.on('combat:ended', () => {
      setEncounter(null);
    });

    return () => {
      socket.off('combat:started');
      socket.off('combat:turn-changed');
      socket.off('combat:hp-updated');
      socket.off('combat:ended');
    };
  }, [socket]);

  if (!encounter) return null;

  const currentCombatant = encounter.combatants[encounter.currentTurn];

  return (
    <div className="w-80 border-l border-gray-800 p-4 space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h2 className="text-h3 font-bold">Combat Tracker</h2>
        {isDM && (
          <Button
            variant="destructive"
            size="sm"
            onClick={() => endCombat(tableId, encounter.id)}
          >
            End
          </Button>
        )}
      </div>

      <div className="text-small text-gray-400">Round {encounter.round}</div>

      {/* Combatants */}
      <div className="space-y-2">
        {encounter.combatants.map((combatant) => (
          <CombatantCard
            key={combatant.id}
            combatant={combatant}
            isCurrent={combatant.id === currentCombatant.id}
            isDM={isDM}
            tableId={tableId}
            encounterId={encounter.id}
          />
        ))}
      </div>

      {/* Next Turn button */}
      {isDM && (
        <Button
          className="w-full"
          onClick={() => nextTurn(tableId, encounter.id)}
        >
          Next Turn
        </Button>
      )}
    </div>
  );
}
```

### Combatant Card Component
```typescript
interface CombatantCardProps {
  combatant: Combatant;
  isCurrent: boolean;
  isDM: boolean;
  tableId: string;
  encounterId: string;
}

function CombatantCard({
  combatant,
  isCurrent,
  isDM,
  tableId,
  encounterId,
}: CombatantCardProps) {
  const hpPercent = (combatant.hp / combatant.maxHp) * 100;
  const hpColor =
    hpPercent > 50 ? 'bg-green-neon' : hpPercent > 25 ? 'bg-yellow-500' : 'bg-red-500';

  const adjustHP = async (delta: number) => {
    const newHP = Math.max(0, Math.min(combatant.maxHp, combatant.hp + delta));

    await fetch(`/api/tables/${tableId}/combat/${encounterId}/combatants/${combatant.id}/hp`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ hp: newHP }),
    });
  };

  return (
    <div
      className={`p-3 rounded-lg border ${
        isCurrent
          ? 'border-green-neon bg-green-neon/10'
          : 'border-gray-800 bg-gray-900'
      }`}
    >
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center gap-2">
          <Avatar className="h-8 w-8">
            <AvatarImage src={combatant.character?.avatarUrl} />
            <AvatarFallback>{combatant.name[0]}</AvatarFallback>
          </Avatar>
          <span className="font-medium">{combatant.name}</span>
          {combatant.isNPC && (
            <Badge variant="outline" className="text-xs">
              NPC
            </Badge>
          )}
        </div>
        <span className="text-small text-gray-400">
          Init: {combatant.initiative}
        </span>
      </div>

      {/* HP Bar */}
      <div className="space-y-1">
        <div className="flex items-center justify-between text-xs">
          <span>{combatant.hp} / {combatant.maxHp} HP</span>
          {combatant.hp === 0 && (
            <Badge variant="destructive">Unconscious</Badge>
          )}
        </div>

        <div className="h-2 bg-gray-800 rounded-full overflow-hidden">
          <motion.div
            className={`h-full ${hpColor}`}
            initial={{ width: `${hpPercent}%` }}
            animate={{ width: `${hpPercent}%` }}
            transition={{ duration: 0.3 }}
          />
        </div>

        {/* HP Adjustment (DM only) */}
        {isDM && (
          <div className="flex gap-1 mt-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => adjustHP(-1)}
              className="flex-1"
            >
              -
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => adjustHP(1)}
              className="flex-1"
            >
              +
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}
```

### Helper Functions
```typescript
// Start combat
async function startCombat(tableId: string, combatants: CombatantInput[]) {
  const response = await fetch(`/api/tables/${tableId}/combat/start`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ combatants }),
  });

  if (!response.ok) throw new Error('Failed to start combat');
  return response.json();
}

// Next turn
async function nextTurn(tableId: string, encounterId: string) {
  const response = await fetch(`/api/tables/${tableId}/combat/${encounterId}/next-turn`, {
    method: 'PATCH',
  });

  if (!response.ok) throw new Error('Failed to advance turn');
  return response.json();
}

// End combat
async function endCombat(tableId: string, encounterId: string) {
  const response = await fetch(`/api/tables/${tableId}/combat/${encounterId}/end`, {
    method: 'POST',
  });

  if (!response.ok) throw new Error('Failed to end combat');
  return response.json();
}

// Roll initiative for character
async function rollInitiative(characterId: string): Promise<number> {
  const response = await fetch(`/api/characters/${characterId}`);
  const { character } = await response.json();

  const dexModifier = Math.floor((character.dexterity - 10) / 2);
  const roll = Math.floor(Math.random() * 20) + 1;

  return roll + dexModifier;
}
```

### Testing

**Test scenarios:**
- DM can start combat encounter
- Initiative rolls automatically with DEX modifier
- Combat tracker displays in initiative order
- Current turn is highlighted
- DM can advance turn (wraps to round 2)
- HP bars update in real-time
- DM can adjust HP with +/- buttons
- HP clamped between 0 and maxHp
- Unconscious badge shows at 0 HP
- DM can end combat
- Combat events broadcast to all table members
- Non-DMs cannot start/end combat or adjust HP

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
