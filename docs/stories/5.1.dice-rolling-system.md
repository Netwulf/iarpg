# Story 5.1: Dice Rolling System (Core Engine)

## Status
Draft

## Story
**As a** Player,
**I want** to roll dice using standard RPG notation (d20, 3d6+5, advantage/disadvantage),
**so that** I can resolve actions and combat using D&D 5e rules.

## Acceptance Criteria
1. Dice notation parser supports standard formats: `1d20`, `3d6+5`, `2d8-2`
2. System supports all D&D dice types: d4, d6, d8, d10, d12, d20, d100
3. Advantage rolls highest of 2d20, disadvantage rolls lowest of 2d20
4. Roll results include individual dice values and total: `[15, 18] = 18 (advantage)`
5. Dice rolls are saved to database with metadata (roller, table, reason)
6. API endpoint accepts roll requests: POST `/api/tables/{id}/roll`
7. Roll results broadcast to table via Socket.io
8. Dice roller validates rolls (max 20 dice per roll, max d100 dice type)

## Tasks / Subtasks

- [ ] Create dice notation parser (AC: 1)
  - [ ] Parse format: `{count}d{sides}[+/-{modifier}]`
  - [ ] Extract: count, sides, modifier
  - [ ] Validate format with regex: `/^(\d+)d(\d+)([+-]\d+)?$/i`
  - [ ] Support uppercase/lowercase: `1D20` or `1d20`
  - [ ] Return parsed object: `{ count, sides, modifier }`

- [ ] Implement dice rolling function (AC: 2)
  - [ ] Generate random number: `Math.floor(Math.random() * sides) + 1`
  - [ ] Roll multiple dice: loop `count` times
  - [ ] Apply modifier to total
  - [ ] Return: `{ rolls: number[], total: number, modifier: number }`
  - [ ] Support dice types: d4, d6, d8, d10, d12, d20, d100

- [ ] Implement advantage/disadvantage (AC: 3, 4)
  - [ ] Advantage: roll 2d20, take highest
  - [ ] Disadvantage: roll 2d20, take lowest
  - [ ] Store both rolls in result: `{ rolls: [15, 18], total: 18, type: 'advantage' }`
  - [ ] Format display: `[15, 18] = 18 (advantage)`

- [ ] Create roll validation (AC: 8)
  - [ ] Max dice per roll: 20
  - [ ] Max dice type: d100
  - [ ] Return error for invalid input
  - [ ] Example errors: "Too many dice", "Invalid dice type"

- [ ] Create dice roll API endpoint (AC: 6)
  - [ ] POST `/api/tables/{tableId}/roll`
  - [ ] Request body: `{ notation, reason, advantage?, disadvantage? }`
  - [ ] Validate user is table member
  - [ ] Parse notation and roll dice
  - [ ] Save to database
  - [ ] Return roll result

- [ ] Save dice rolls to database (AC: 5)
  - [ ] Create `DiceRoll` model in Prisma schema
  - [ ] Fields: id, tableId, userId, characterId, notation, rolls, total, type, reason, createdAt
  - [ ] Save with metadata (who rolled, why)
  - [ ] Index by tableId for fast queries

- [ ] Broadcast roll results (AC: 7)
  - [ ] After saving, emit Socket.io event: `roll:new`
  - [ ] Event data: `{ roll: {...}, user: {...}, character: {...} }`
  - [ ] Broadcast to table room: `io.to('table:{id}')`
  - [ ] All members receive and display roll

- [ ] Create dice roll service (AC: 1-4)
  - [ ] `parseDiceNotation(notation: string)`
  - [ ] `rollDice(sides: number, count: number)`
  - [ ] `rollWithModifier(notation: string)`
  - [ ] `rollWithAdvantage(notation: string)`
  - [ ] `rollWithDisadvantage(notation: string)`

- [ ] Add roll reason/context (AC: 5)
  - [ ] Optional `reason` field: "Attack roll", "Perception check"
  - [ ] Display in chat with roll result
  - [ ] Examples: "Alice rolled 1d20+5 for Attack roll: 18"
  - [ ] DM can roll for NPCs (mark as "DM Roll")

- [ ] Handle edge cases
  - [ ] Invalid notation: return helpful error
  - [ ] Modifier larger than total: allow (can result in negative)
  - [ ] Zero dice: return error
  - [ ] Fractional dice: return error (e.g., "1.5d6")

## Dev Notes

### Dice Notation Examples
**[Source: D&D 5e rules and standard RPG notation]**

```
1d20        → Roll 1 twenty-sided die
3d6         → Roll 3 six-sided dice
2d8+5       → Roll 2 eight-sided dice, add 5
1d20-2      → Roll 1 twenty-sided die, subtract 2
4d6kh3      → Roll 4d6, keep highest 3 (ability scores - optional)
1d20 adv    → Roll 2d20, take highest (advantage)
1d20 dis    → Roll 2d20, take lowest (disadvantage)
```

### Dice Rolling Service
**[Source: Best practices for dice rolling systems]**

```typescript
// packages/dice/src/index.ts
export interface DiceRoll {
  notation: string;
  rolls: number[];
  total: number;
  modifier: number;
  type?: 'normal' | 'advantage' | 'disadvantage' | 'critical';
  reason?: string;
}

export interface ParsedNotation {
  count: number;
  sides: number;
  modifier: number;
}

export class DiceRoller {
  private static readonly MAX_DICE = 20;
  private static readonly MAX_SIDES = 100;
  private static readonly NOTATION_REGEX = /^(\d+)d(\d+)([+-]\d+)?$/i;

  /**
   * Parse dice notation string into components
   * @example parseDiceNotation('3d6+5') → { count: 3, sides: 6, modifier: 5 }
   */
  static parseDiceNotation(notation: string): ParsedNotation {
    const match = notation.trim().match(this.NOTATION_REGEX);

    if (!match) {
      throw new Error(`Invalid dice notation: ${notation}`);
    }

    const count = parseInt(match[1], 10);
    const sides = parseInt(match[2], 10);
    const modifier = match[3] ? parseInt(match[3], 10) : 0;

    // Validation
    if (count < 1 || count > this.MAX_DICE) {
      throw new Error(`Dice count must be between 1 and ${this.MAX_DICE}`);
    }

    if (sides < 2 || sides > this.MAX_SIDES) {
      throw new Error(`Dice sides must be between 2 and ${this.MAX_SIDES}`);
    }

    // Validate standard D&D dice types
    const validSides = [4, 6, 8, 10, 12, 20, 100];
    if (!validSides.includes(sides)) {
      throw new Error(`Invalid dice type: d${sides}. Use d4, d6, d8, d10, d12, d20, or d100`);
    }

    return { count, sides, modifier };
  }

  /**
   * Roll a single die
   */
  static rollDie(sides: number): number {
    return Math.floor(Math.random() * sides) + 1;
  }

  /**
   * Roll multiple dice
   */
  static rollDice(sides: number, count: number): number[] {
    const rolls: number[] = [];
    for (let i = 0; i < count; i++) {
      rolls.push(this.rollDie(sides));
    }
    return rolls;
  }

  /**
   * Roll dice using notation string
   * @example roll('3d6+5') → { notation: '3d6+5', rolls: [4, 5, 3], total: 17, modifier: 5 }
   */
  static roll(notation: string, reason?: string): DiceRoll {
    const parsed = this.parseDiceNotation(notation);
    const rolls = this.rollDice(parsed.sides, parsed.count);
    const rollTotal = rolls.reduce((sum, roll) => sum + roll, 0);
    const total = rollTotal + parsed.modifier;

    return {
      notation,
      rolls,
      total,
      modifier: parsed.modifier,
      type: 'normal',
      reason,
    };
  }

  /**
   * Roll with advantage (2d20, take highest)
   */
  static rollWithAdvantage(baseNotation: string, reason?: string): DiceRoll {
    const parsed = this.parseDiceNotation(baseNotation);

    if (parsed.sides !== 20 || parsed.count !== 1) {
      throw new Error('Advantage only works with 1d20 rolls');
    }

    const rolls = this.rollDice(20, 2);
    const highest = Math.max(...rolls);
    const total = highest + parsed.modifier;

    return {
      notation: `${baseNotation} (advantage)`,
      rolls,
      total,
      modifier: parsed.modifier,
      type: 'advantage',
      reason,
    };
  }

  /**
   * Roll with disadvantage (2d20, take lowest)
   */
  static rollWithDisadvantage(baseNotation: string, reason?: string): DiceRoll {
    const parsed = this.parseDiceNotation(baseNotation);

    if (parsed.sides !== 20 || parsed.count !== 1) {
      throw new Error('Disadvantage only works with 1d20 rolls');
    }

    const rolls = this.rollDice(20, 2);
    const lowest = Math.min(...rolls);
    const total = lowest + parsed.modifier;

    return {
      notation: `${baseNotation} (disadvantage)`,
      rolls,
      total,
      modifier: parsed.modifier,
      type: 'disadvantage',
      reason,
    };
  }

  /**
   * Check if roll is a critical hit (natural 20)
   */
  static isCriticalHit(roll: DiceRoll): boolean {
    return roll.rolls.length === 1 && roll.rolls[0] === 20;
  }

  /**
   * Check if roll is a critical miss (natural 1)
   */
  static isCriticalMiss(roll: DiceRoll): boolean {
    return roll.rolls.length === 1 && roll.rolls[0] === 1;
  }
}
```

### API Controller
**[Source: Architecture Section 5.1.6 - Dice Roll Endpoints]**

```typescript
// apps/api/src/controllers/dice.controller.ts
import { Request, Response, NextFunction } from 'express';
import { prisma } from '@iarpg/db';
import { DiceRoller } from '@iarpg/dice';

export const diceController = {
  async roll(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId } = req.params;
      const userId = req.user!.id;
      const { notation, reason, advantage, disadvantage } = req.body;

      // Validate user is table member
      const membership = await prisma.tableMember.findFirst({
        where: { tableId, userId },
        include: {
          character: {
            select: { id: true, name: true },
          },
        },
      });

      if (!membership) {
        return res.status(403).json({ error: 'Not a table member' });
      }

      // Roll dice
      let rollResult: DiceRoll;
      try {
        if (advantage) {
          rollResult = DiceRoller.rollWithAdvantage(notation, reason);
        } else if (disadvantage) {
          rollResult = DiceRoller.rollWithDisadvantage(notation, reason);
        } else {
          rollResult = DiceRoller.roll(notation, reason);
        }
      } catch (error) {
        return res.status(400).json({ error: error.message });
      }

      // Check for critical hit/miss
      if (DiceRoller.isCriticalHit(rollResult)) {
        rollResult.type = 'critical';
      } else if (DiceRoller.isCriticalMiss(rollResult)) {
        rollResult.type = 'critical';
      }

      // Save to database
      const diceRoll = await prisma.diceRoll.create({
        data: {
          tableId,
          userId,
          characterId: membership.characterId,
          notation: rollResult.notation,
          rolls: rollResult.rolls,
          total: rollResult.total,
          modifier: rollResult.modifier,
          type: rollResult.type || 'normal',
          reason: rollResult.reason,
        },
        include: {
          user: {
            select: { id: true, username: true, avatar: true },
          },
          character: {
            select: { id: true, name: true },
          },
        },
      });

      // Broadcast to table room
      req.io.to(`table:${tableId}`).emit('roll:new', { roll: diceRoll });

      res.status(201).json({ roll: diceRoll });
    } catch (error) {
      next(error);
    }
  },

  async getRollHistory(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId } = req.params;
      const { limit = 20 } = req.query;

      const rolls = await prisma.diceRoll.findMany({
        where: { tableId },
        include: {
          user: {
            select: { username: true, avatar: true },
          },
          character: {
            select: { name: true },
          },
        },
        orderBy: { createdAt: 'desc' },
        take: Number(limit),
      });

      res.json({ rolls });
    } catch (error) {
      next(error);
    }
  },
};
```

### Prisma Schema Addition
**[Source: Architecture Section 4.6 - DiceRoll Model]**

```prisma
model DiceRoll {
  id          String   @id @default(cuid())
  tableId     String
  userId      String
  characterId String?
  notation    String   // Original notation (e.g., "3d6+5")
  rolls       Int[]    // Individual die results [4, 5, 3]
  total       Int      // Final total (12 in above example)
  modifier    Int      @default(0)
  type        String   @default("normal") // normal, advantage, disadvantage, critical
  reason      String?  // "Attack roll", "Perception check"
  createdAt   DateTime @default(now())

  table       Table      @relation(fields: [tableId], references: [id], onDelete: Cascade)
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  character   Character? @relation(fields: [characterId], references: [id], onDelete: SetNull)

  @@index([tableId, createdAt])
}
```

### API Routes
```typescript
// apps/api/src/routes/dice.routes.ts
import { Router } from 'express';
import { diceController } from '../controllers/dice.controller';
import { authenticate } from '../middleware/auth.middleware';

const router = Router();

router.post('/tables/:tableId/roll', authenticate, diceController.roll);
router.get('/tables/:tableId/rolls', authenticate, diceController.getRollHistory);

export default router;
```

### Usage Examples

```typescript
// Basic roll
const result = DiceRoller.roll('1d20+5');
// { notation: '1d20+5', rolls: [15], total: 20, modifier: 5, type: 'normal' }

// Damage roll
const damage = DiceRoller.roll('2d8+3', 'Longsword damage');
// { notation: '2d8+3', rolls: [6, 4], total: 13, modifier: 3, reason: 'Longsword damage' }

// Advantage
const advantage = DiceRoller.rollWithAdvantage('1d20+5', 'Attack roll');
// { notation: '1d20+5 (advantage)', rolls: [12, 18], total: 23, modifier: 5, type: 'advantage' }

// Disadvantage
const disadvantage = DiceRoller.rollWithDisadvantage('1d20+2', 'Stealth check');
// { notation: '1d20+2 (disadvantage)', rolls: [15, 7], total: 9, modifier: 2, type: 'disadvantage' }

// Multiple dice
const stats = DiceRoller.roll('4d6');
// { notation: '4d6', rolls: [4, 5, 3, 6], total: 18, modifier: 0 }
```

### Client-side Roll Function
```typescript
// apps/web/src/lib/dice.ts
export async function rollDice(
  tableId: string,
  notation: string,
  options?: {
    reason?: string;
    advantage?: boolean;
    disadvantage?: boolean;
  }
) {
  const response = await fetch(`/api/tables/${tableId}/roll`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      notation,
      reason: options?.reason,
      advantage: options?.advantage,
      disadvantage: options?.disadvantage,
    }),
  });

  if (!response.ok) {
    const { error } = await response.json();
    throw new Error(error);
  }

  return response.json();
}
```

### Testing

**Unit tests for DiceRoller:**
```typescript
describe('DiceRoller', () => {
  test('parses basic notation', () => {
    const parsed = DiceRoller.parseDiceNotation('3d6+5');
    expect(parsed).toEqual({ count: 3, sides: 6, modifier: 5 });
  });

  test('rolls correct number of dice', () => {
    const result = DiceRoller.roll('4d6');
    expect(result.rolls).toHaveLength(4);
    expect(result.rolls.every(r => r >= 1 && r <= 6)).toBe(true);
  });

  test('applies modifier correctly', () => {
    const result = DiceRoller.roll('1d6+5');
    const expected = result.rolls[0] + 5;
    expect(result.total).toBe(expected);
  });

  test('advantage takes highest of 2d20', () => {
    const result = DiceRoller.rollWithAdvantage('1d20');
    expect(result.rolls).toHaveLength(2);
    expect(result.total).toBe(Math.max(...result.rolls));
  });

  test('disadvantage takes lowest of 2d20', () => {
    const result = DiceRoller.rollWithDisadvantage('1d20');
    expect(result.rolls).toHaveLength(2);
    expect(result.total).toBe(Math.min(...result.rolls));
  });

  test('detects critical hit', () => {
    const result = { rolls: [20], total: 20, notation: '1d20', modifier: 0, type: 'normal' };
    expect(DiceRoller.isCriticalHit(result)).toBe(true);
  });

  test('rejects invalid notation', () => {
    expect(() => DiceRoller.parseDiceNotation('abc')).toThrow();
    expect(() => DiceRoller.parseDiceNotation('1d')).toThrow();
  });

  test('rejects too many dice', () => {
    expect(() => DiceRoller.parseDiceNotation('100d6')).toThrow('Dice count must be between 1 and 20');
  });

  test('rejects invalid dice type', () => {
    expect(() => DiceRoller.parseDiceNotation('1d7')).toThrow('Invalid dice type');
  });
});
```

**Integration tests:**
- API accepts roll requests and saves to database
- Roll results broadcast to table members via Socket.io
- Roll history endpoint returns recent rolls
- Non-members cannot roll dice in table
- Invalid notation returns 400 error

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
