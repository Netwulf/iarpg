# Story 6.3: AI Combat Suggestions (Player Assist)

## Status
Draft

## Story
**As a** Player,
**I want** AI to suggest tactical actions during my combat turn,
**so that** I can make informed decisions and learn combat mechanics.

## Acceptance Criteria
1. Players see "AI Suggest" button during their combat turn
2. AI analyzes current combat state (HP, positioning, abilities, enemies)
3. Suggestions include: best attack target, spell choices, tactical movement
4. Suggestions explain reasoning: "Target goblin archer - low HP, high threat"
5. Players can accept suggestion (auto-fills action) or ignore
6. Suggestions consider character class, level, available spells/abilities
7. AI respects D&D 5e action economy (action, bonus action, movement)
8. Free tier: 3 suggestions per combat, Premium: unlimited

## Tasks / Subtasks

- [ ] Add "AI Suggest" button to combat UI (AC: 1)
  - [ ] Show button next to current combatant card
  - [ ] Only visible during player's turn (not NPC/DM turns)
  - [ ] Disabled if player used all suggestions
  - [ ] Show remaining suggestions count

- [ ] Build combat state context (AC: 2)
  - [ ] Current combatant: HP, class, level, abilities, spells
  - [ ] All combatants: HP, AC, position in initiative
  - [ ] Available actions: attack, spells, abilities, items
  - [ ] Combat history: last 3 rounds of actions
  - [ ] Terrain/conditions (future enhancement)

- [ ] Generate tactical suggestions (AC: 3, 4)
  - [ ] Call Claude API with combat context
  - [ ] Request 2-3 action suggestions ranked by effectiveness
  - [ ] Each suggestion includes: action, target, reasoning
  - [ ] Format: "Attack goblin archer with longsword - low HP (5/15), high threat"

- [ ] Consider character abilities (AC: 6)
  - [ ] Fetch character's class features
  - [ ] Fetch available spells (if spellcaster)
  - [ ] Fetch equipped weapons/items
  - [ ] Include proficiency bonus in calculations
  - [ ] Suggest class-appropriate tactics

- [ ] Respect action economy (AC: 7)
  - [ ] Action: attack, cast spell, dash, dodge, help
  - [ ] Bonus Action: off-hand attack, spells with bonus action
  - [ ] Movement: up to character's speed
  - [ ] Reaction: opportunity attacks (future)
  - [ ] AI suggests full turn: "Action + Bonus Action + Movement"

- [ ] Create suggestion display modal (AC: 4, 5)
  - [ ] Modal title: "AI Combat Suggestions"
  - [ ] List 2-3 suggestions with icons
  - [ ] Each shows: action type, target, damage estimate, reasoning
  - [ ] "Use This" button for each suggestion
  - [ ] "Ignore" button to close modal

- [ ] Implement suggestion acceptance (AC: 5)
  - [ ] "Use This" pre-fills action in combat UI
  - [ ] Auto-selects target (if applicable)
  - [ ] Shows dice roll (if attack/spell)
  - [ ] Player confirms before executing
  - [ ] Can still modify before confirming

- [ ] Track suggestion usage (AC: 8)
  - [ ] Count suggestions per combat per player
  - [ ] Free tier: 3 suggestions per combat
  - [ ] Premium: unlimited
  - [ ] Reset count when combat ends
  - [ ] Show "2/3 suggestions remaining"

- [ ] Create suggestion API endpoint (AC: 2, 3)
  - [ ] POST `/api/tables/{tableId}/combat/{encounterId}/suggest`
  - [ ] Validate it's player's turn
  - [ ] Fetch combat state and character data
  - [ ] Call Claude API
  - [ ] Return 2-3 ranked suggestions

- [ ] Handle AI suggestions rate limiting (AC: 8)
  - [ ] Store suggestion count in combat state (in-memory or DB)
  - [ ] Check tier before generating
  - [ ] Return 403 if limit exceeded
  - [ ] Show upgrade CTA for free users

## Dev Notes

### AI Combat Suggestion System Prompt
**[Source: D&D 5e tactical combat principles]**

```typescript
function buildCombatSuggestionPrompt(context: {
  character: Character;
  combatants: Combatant[];
  currentTurn: number;
  recentActions: string[];
}): string {
  const { character, combatants, currentTurn, recentActions } = context;

  const currentCombatant = combatants[currentTurn];
  const allies = combatants.filter(c => !c.isNPC && c.id !== currentCombatant.id);
  const enemies = combatants.filter(c => c.isNPC);

  return `You are a D&D 5e tactical combat advisor. Suggest the best actions for the current turn.

**Current Character:**
- Name: ${character.name}
- Class: ${character.class}, Level ${character.level}
- HP: ${currentCombatant.hp}/${currentCombatant.maxHp}
- AC: ${character.ac}
- Proficiency Bonus: +${character.proficiencyBonus}

**Available Actions:**
${character.class === 'Fighter' || character.class === 'Barbarian'
  ? '- Attack with weapon (1d20 + STR/DEX modifier + proficiency)'
  : ''}
${character.class === 'Wizard' || character.class === 'Cleric'
  ? '- Cast spell (varies by spell level)'
  : ''}
- Dash (move up to speed again)
- Dodge (disadvantage on attacks against you)
- Help (give ally advantage)

**Allies:**
${allies.map(a => `- ${a.name}: ${a.hp}/${a.maxHp} HP`).join('\n')}

**Enemies:**
${enemies.map(e => `- ${e.name}: ${e.hp}/${e.maxHp} HP (AC unknown)`).join('\n')}

**Recent Combat Actions:**
${recentActions.join('\n')}

**Task:**
Suggest 2-3 tactical actions for this turn, ranked by effectiveness. For each suggestion:
1. Action type (Attack, Cast Spell, Dash, etc.)
2. Target (if applicable)
3. Brief reasoning (1 sentence)

Format each suggestion as:
**[Action]** Target: [target] - Reasoning: [why]

Example:
**Attack** Target: Goblin Archer - Low HP (5/15), high damage dealer, easy kill
**Cast Healing Word** Target: Fighter ally - Critical HP (8/42), bonus action preserves your action
**Dash** Move behind cover - Avoid attacks of opportunity, reposition for next turn

Provide suggestions now:`;
}
```

### API Controller
**[Source: Architecture Section 5.1.10 - Combat Suggestion Endpoint]**

```typescript
// apps/api/src/controllers/combatSuggestion.controller.ts
export const combatSuggestionController = {
  async suggest(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId, encounterId } = req.params;
      const userId = req.user!.id;

      // Fetch combat encounter
      const encounter = await prisma.combatEncounter.findUnique({
        where: { id: encounterId },
        include: {
          combatants: {
            include: {
              character: true,
            },
            orderBy: { position: 'asc' },
          },
        },
      });

      if (!encounter) {
        return res.status(404).json({ error: 'Combat not found' });
      }

      const currentCombatant = encounter.combatants[encounter.currentTurn];

      // Verify it's the requesting user's turn
      if (currentCombatant.userId !== userId) {
        return res.status(403).json({ error: 'Not your turn' });
      }

      // Check usage limits
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { tier: true },
      });

      if (user?.tier === 'free') {
        // Get suggestion count for this combat
        const suggestionCount = await prisma.aIUsage.count({
          where: {
            userId,
            tableId,
            createdAt: { gte: encounter.createdAt },
            prompt: { contains: '[Combat Suggestion]' },
          },
        });

        if (suggestionCount >= 3) {
          return res.status(403).json({
            error: 'Suggestion limit reached. Upgrade to premium for unlimited suggestions.',
          });
        }
      }

      // Fetch recent combat actions
      const recentMessages = await prisma.message.findMany({
        where: {
          tableId,
          createdAt: { gte: encounter.createdAt },
          type: { in: ['text', 'roll'] },
        },
        orderBy: { createdAt: 'desc' },
        take: 10,
      });

      const recentActions = recentMessages
        .reverse()
        .map(m => m.content)
        .slice(-5);

      // Build context
      const context = {
        character: currentCombatant.character!,
        combatants: encounter.combatants,
        currentTurn: encounter.currentTurn,
        recentActions,
      };

      // Generate suggestions
      const systemPrompt = buildCombatSuggestionPrompt(context);

      const response = await anthropic.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 512,
        temperature: 0.6,
        system: systemPrompt,
        messages: [
          {
            role: 'user',
            content: 'Suggest optimal combat actions for my turn.',
          },
        ],
      });

      const suggestions = response.content[0].text;

      // Track usage
      await prisma.aIUsage.create({
        data: {
          userId,
          tableId,
          prompt: `[Combat Suggestion] ${currentCombatant.character!.name}`,
          response: suggestions,
          tokensUsed: response.usage.input_tokens + response.usage.output_tokens,
          cost: calculateCost(
            response.usage.input_tokens + response.usage.output_tokens,
            'claude-3-5-sonnet-20241022'
          ),
        },
      });

      res.json({ suggestions });
    } catch (error) {
      next(error);
    }
  },

  async getRemainingCount(req: Request, res: Response, next: NextFunction) {
    try {
      const { tableId, encounterId } = req.params;
      const userId = req.user!.id;

      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { tier: true },
      });

      if (user?.tier === 'premium' || user?.tier === 'master') {
        return res.json({ remaining: 'unlimited' });
      }

      const encounter = await prisma.combatEncounter.findUnique({
        where: { id: encounterId },
      });

      if (!encounter) {
        return res.status(404).json({ error: 'Combat not found' });
      }

      const suggestionCount = await prisma.aIUsage.count({
        where: {
          userId,
          tableId,
          createdAt: { gte: encounter.createdAt },
          prompt: { contains: '[Combat Suggestion]' },
        },
      });

      res.json({ remaining: Math.max(0, 3 - suggestionCount), limit: 3 });
    } catch (error) {
      next(error);
    }
  },
};
```

### Combat Suggestion UI Component
```typescript
interface CombatSuggestionProps {
  tableId: string;
  encounterId: string;
  combatantId: string;
  isPlayerTurn: boolean;
}

export function CombatSuggestion({
  tableId,
  encounterId,
  combatantId,
  isPlayerTurn,
}: CombatSuggestionProps) {
  const [suggestions, setSuggestions] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [remaining, setRemaining] = useState<number | 'unlimited'>(3);
  const [showModal, setShowModal] = useState(false);

  const fetchRemaining = async () => {
    const res = await fetch(
      `/api/tables/${tableId}/combat/${encounterId}/suggestions/remaining`
    );
    const data = await res.json();
    setRemaining(data.remaining);
  };

  const handleSuggest = async () => {
    setLoading(true);

    try {
      const response = await fetch(
        `/api/tables/${tableId}/combat/${encounterId}/suggest`,
        {
          method: 'POST',
        }
      );

      if (!response.ok) {
        if (response.status === 403) {
          const { error } = await response.json();
          toast.error(error);
          return;
        }
        throw new Error('Failed to get suggestions');
      }

      const { suggestions } = await response.json();
      setSuggestions(suggestions);
      setShowModal(true);
      fetchRemaining();
    } catch (error) {
      toast.error('Failed to get AI suggestions');
    } finally {
      setLoading(false);
    }
  };

  if (!isPlayerTurn) return null;

  return (
    <>
      <Button
        variant="outline"
        size="sm"
        onClick={handleSuggest}
        disabled={loading || remaining === 0}
        className="border-blue-500 text-blue-500"
      >
        <Sparkles className="w-4 h-4 mr-1" />
        AI Suggest
        {remaining !== 'unlimited' && (
          <span className="ml-1 text-xs">({remaining}/3)</span>
        )}
      </Button>

      <Dialog open={showModal} onOpenChange={setShowModal}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>AI Combat Suggestions âœ¨</DialogTitle>
          </DialogHeader>

          <div className="prose prose-invert max-w-none">
            <ReactMarkdown>{suggestions}</ReactMarkdown>
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={() => setShowModal(false)}>
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}
```

### Parse Suggestions (Optional Enhancement)
```typescript
interface ParsedSuggestion {
  action: string;
  target?: string;
  reasoning: string;
}

function parseSuggestions(text: string): ParsedSuggestion[] {
  const suggestions: ParsedSuggestion[] = [];
  const lines = text.split('\n').filter(line => line.trim());

  for (const line of lines) {
    // Match: **[Action]** Target: [target] - Reasoning: [reason]
    const match = line.match(/\*\*(.+?)\*\*.*?Target:\s*(.+?)\s*-\s*Reasoning:\s*(.+)/i);

    if (match) {
      suggestions.push({
        action: match[1].trim(),
        target: match[2].trim(),
        reasoning: match[3].trim(),
      });
    }
  }

  return suggestions;
}

// Usage in component
const parsedSuggestions = parseSuggestions(suggestions);

{parsedSuggestions.map((suggestion, idx) => (
  <Card key={idx} className="p-4">
    <div className="flex items-start justify-between">
      <div className="flex-1">
        <h4 className="font-bold text-lg">{suggestion.action}</h4>
        {suggestion.target && (
          <p className="text-sm text-gray-400">Target: {suggestion.target}</p>
        )}
        <p className="text-sm mt-2">{suggestion.reasoning}</p>
      </div>
      <Button
        size="sm"
        onClick={() => handleUseSuggestion(suggestion)}
      >
        Use This
      </Button>
    </div>
  </Card>
))}
```

### Usage Tracking in Combat State
```typescript
// Optional: Store in-memory counter (resets on server restart)
const combatSuggestionCounts = new Map<string, number>();

function incrementSuggestionCount(userId: string, encounterId: string): void {
  const key = `${userId}:${encounterId}`;
  const current = combatSuggestionCounts.get(key) || 0;
  combatSuggestionCounts.set(key, current + 1);
}

function getSuggestionCount(userId: string, encounterId: string): number {
  const key = `${userId}:${encounterId}`;
  return combatSuggestionCounts.get(key) || 0;
}

function resetSuggestionCount(encounterId: string): void {
  // Clear all counts for this encounter when combat ends
  for (const key of combatSuggestionCounts.keys()) {
    if (key.endsWith(`:${encounterId}`)) {
      combatSuggestionCounts.delete(key);
    }
  }
}
```

### Testing

**Test scenarios:**
- AI Suggest button appears during player's turn
- Button hidden during NPC/DM turns
- AI generates 2-3 tactical suggestions
- Suggestions consider character class and abilities
- Suggestions respect D&D 5e action economy
- Suggestions explain reasoning clearly
- Free tier limited to 3 suggestions per combat
- Premium tier has unlimited suggestions
- Suggestion count resets when combat ends
- Modal displays suggestions clearly
- Player can accept or ignore suggestions
- Rate limit enforced correctly
- Upgrade CTA shown when limit reached

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
