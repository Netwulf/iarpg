# Story 7.2: Notification System (Email + Push)

## Status
Draft

## Story
**As a** Player,
**I want** to receive notifications when it's my turn or important events happen,
**so that** I don't miss my turn in async games.

## Acceptance Criteria
1. Players receive email when their turn starts in async mode
2. Players receive in-app notifications for: turn start, messages, dice rolls
3. Users can configure notification preferences (email on/off, types)
4. Email includes: table name, deadline, direct link to table
5. In-app notifications show in bell icon dropdown
6. Notifications marked as read when clicked
7. Push notifications (web push) for desktop browsers (optional)
8. Notification preferences stored per user

## Tasks / Subtasks

- [ ] Create Notification database model (AC: 2, 5, 6)
  - [ ] Fields: id, userId, type, title, message, link, read, createdAt
  - [ ] Types: turn_start, message, dice_roll, combat_start, table_invite
  - [ ] Index on userId and read status

- [ ] Build email notification system (AC: 1, 4)
  - [ ] Install nodemailer or Resend SDK
  - [ ] Create email templates (HTML + text)
  - [ ] Send email when async turn starts
  - [ ] Include table name, deadline, CTA link
  - [ ] Track email sent status

- [ ] Create turn start email template (AC: 4)
  - [ ] Subject: "Your turn in {tableName}"
  - [ ] Body: "It's your turn! You have {deadline} to post your action."
  - [ ] CTA button: "View Table"
  - [ ] Link: `https://app.iarpg.com/tables/{tableId}`

- [ ] Implement in-app notifications (AC: 2, 5)
  - [ ] Bell icon in navbar with unread count badge
  - [ ] Dropdown shows recent notifications (last 10)
  - [ ] Each notification: icon, title, timestamp, link
  - [ ] Click notification â†’ mark as read + navigate to link

- [ ] Create notification preferences UI (AC: 3, 8)
  - [ ] Settings page: `/settings/notifications`
  - [ ] Toggle: Email notifications on/off
  - [ ] Checkboxes: Which events to notify (turn, messages, dice, combat)
  - [ ] Save preferences to user profile

- [ ] Store notification preferences (AC: 8)
  - [ ] Add to User model: notificationSettings (JSON)
  - [ ] Structure: `{ email: true, types: ['turn_start', 'message'] }`
  - [ ] Default: email on, all types enabled

- [ ] Send notifications on events (AC: 2)
  - [ ] Turn start â†’ email + in-app notification
  - [ ] New message in table â†’ in-app notification
  - [ ] Dice roll â†’ in-app notification
  - [ ] Combat start â†’ in-app notification

- [ ] Create notification API endpoints (AC: 5, 6)
  - [ ] GET `/api/notifications` - List user's notifications
  - [ ] PATCH `/api/notifications/{id}/read` - Mark as read
  - [ ] DELETE `/api/notifications/{id}` - Delete notification
  - [ ] POST `/api/notifications/mark-all-read` - Mark all as read

- [ ] Add notification bell component (AC: 5)
  - [ ] Bell icon in navbar
  - [ ] Unread count badge (red dot)
  - [ ] Dropdown with scrollable list
  - [ ] "Mark all as read" button
  - [ ] Empty state: "No notifications"

- [ ] Implement web push notifications (AC: 7, optional)
  - [ ] Request push permission on login
  - [ ] Subscribe to push service (FCM or Web Push API)
  - [ ] Send push when turn starts (if browser supports)
  - [ ] Handle push click â†’ open table page

## Dev Notes

### Notification Database Model
**[Source: Architecture Section 4.11 - Notification Model]**

```prisma
model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String   // turn_start, message, dice_roll, combat_start, table_invite
  title     String
  message   String   @db.Text
  link      String?  // URL to navigate to
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([createdAt])
}

// Update User model
model User {
  // ... existing fields
  notificationSettings Json @default("{\"email\":true,\"types\":[\"turn_start\",\"message\",\"dice_roll\",\"combat_start\"]}")

  notifications Notification[]
}
```

### Email Service
**[Source: Best practices for transactional emails]**

```typescript
// packages/email/src/index.ts
import nodemailer from 'nodemailer';
import { Resend } from 'resend';

const resend = new Resend(process.env.RESEND_API_KEY);

export interface EmailOptions {
  to: string;
  subject: string;
  html: string;
  text: string;
}

export async function sendEmail(options: EmailOptions): Promise<void> {
  try {
    await resend.emails.send({
      from: 'IA-RPG <noreply@iarpg.com>',
      to: options.to,
      subject: options.subject,
      html: options.html,
      text: options.text,
    });
  } catch (error) {
    console.error('Failed to send email:', error);
    throw error;
  }
}

export function buildTurnStartEmail(data: {
  username: string;
  tableName: string;
  deadline: string;
  tableUrl: string;
}): EmailOptions {
  const { username, tableName, deadline, tableUrl } = data;

  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { font-family: sans-serif; line-height: 1.6; color: #333; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .header { background: #0A0A0A; color: #39FF14; padding: 20px; text-align: center; }
    .content { padding: 30px 20px; background: #f9f9f9; }
    .button { display: inline-block; padding: 12px 24px; background: #39FF14; color: #0A0A0A; text-decoration: none; border-radius: 4px; font-weight: bold; }
    .footer { text-align: center; padding: 20px; font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ðŸŽ² It's Your Turn!</h1>
    </div>
    <div class="content">
      <p>Hi ${username},</p>
      <p>It's your turn in <strong>${tableName}</strong>!</p>
      <p>You have <strong>${deadline}</strong> to post your action.</p>
      <p style="text-align: center; margin: 30px 0;">
        <a href="${tableUrl}" class="button">View Table</a>
      </p>
      <p style="color: #666; font-size: 14px;">
        Don't let your party wait! Log in and make your move.
      </p>
    </div>
    <div class="footer">
      <p>IA-RPG - Play D&D Anytime, Anywhere</p>
      <p><a href="${tableUrl}/settings/notifications">Notification Settings</a></p>
    </div>
  </div>
</body>
</html>`;

  const text = `
Hi ${username},

It's your turn in ${tableName}!

You have ${deadline} to post your action.

View table: ${tableUrl}

---
IA-RPG - Play D&D Anytime, Anywhere
Notification Settings: ${tableUrl}/settings/notifications
`;

  return {
    to: '', // Will be filled by caller
    subject: `Your turn in ${tableName}`,
    html,
    text,
  };
}
```

### Notification Service
**[Source: Architecture Section 5.2 - Notification Service]**

```typescript
// apps/api/src/services/notification.service.ts
import { prisma } from '@iarpg/db';
import { sendEmail, buildTurnStartEmail } from '@iarpg/email';

export class NotificationService {
  async notifyTurnStart(userId: string, tableId: string, deadline: Date) {
    // Fetch user preferences
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        email: true,
        username: true,
        notificationSettings: true,
      },
    });

    if (!user) return;

    const settings = user.notificationSettings as {
      email: boolean;
      types: string[];
    };

    // Check if user wants turn_start notifications
    if (!settings.types.includes('turn_start')) return;

    // Fetch table info
    const table = await prisma.table.findUnique({
      where: { id: tableId },
      select: { name: true },
    });

    if (!table) return;

    // Create in-app notification
    await prisma.notification.create({
      data: {
        userId,
        type: 'turn_start',
        title: `Your turn in ${table.name}`,
        message: `It's your turn! You have until ${deadline.toLocaleString()} to post your action.`,
        link: `/tables/${tableId}`,
      },
    });

    // Send email if enabled
    if (settings.email) {
      const deadlineStr = this.formatDeadline(deadline);
      const tableUrl = `${process.env.APP_URL}/tables/${tableId}`;

      const emailContent = buildTurnStartEmail({
        username: user.username,
        tableName: table.name,
        deadline: deadlineStr,
        tableUrl,
      });

      await sendEmail({
        ...emailContent,
        to: user.email,
      });
    }
  }

  async notifyNewMessage(userId: string, tableId: string, from: string, preview: string) {
    // Similar structure to notifyTurnStart
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { notificationSettings: true },
    });

    if (!user) return;

    const settings = user.notificationSettings as {
      email: boolean;
      types: string[];
    };

    if (!settings.types.includes('message')) return;

    await prisma.notification.create({
      data: {
        userId,
        type: 'message',
        title: `New message from ${from}`,
        message: preview,
        link: `/tables/${tableId}`,
      },
    });
  }

  private formatDeadline(deadline: Date): string {
    const now = new Date();
    const diff = deadline.getTime() - now.getTime();
    const hours = Math.floor(diff / (1000 * 60 * 60));

    if (hours >= 24) {
      const days = Math.floor(hours / 24);
      return `${days} day${days > 1 ? 's' : ''}`;
    }

    return `${hours} hour${hours > 1 ? 's' : ''}`;
  }
}

export const notificationService = new NotificationService();
```

### Notification API Controller
```typescript
// apps/api/src/controllers/notification.controller.ts
export const notificationController = {
  async list(req: Request, res: Response, next: NextFunction) {
    try {
      const userId = req.user!.id;
      const { limit = 20, unreadOnly = false } = req.query;

      const notifications = await prisma.notification.findMany({
        where: {
          userId,
          ...(unreadOnly === 'true' && { read: false }),
        },
        orderBy: { createdAt: 'desc' },
        take: Number(limit),
      });

      const unreadCount = await prisma.notification.count({
        where: { userId, read: false },
      });

      res.json({ notifications, unreadCount });
    } catch (error) {
      next(error);
    }
  },

  async markAsRead(req: Request, res: Response, next: NextFunction) {
    try {
      const { id } = req.params;
      const userId = req.user!.id;

      const notification = await prisma.notification.updateMany({
        where: { id, userId },
        data: { read: true },
      });

      res.json({ success: true });
    } catch (error) {
      next(error);
    }
  },

  async markAllAsRead(req: Request, res: Response, next: NextFunction) {
    try {
      const userId = req.user!.id;

      await prisma.notification.updateMany({
        where: { userId, read: false },
        data: { read: true },
      });

      res.json({ success: true });
    } catch (error) {
      next(error);
    }
  },

  async delete(req: Request, res: Response, next: NextFunction) {
    try {
      const { id } = req.params;
      const userId = req.user!.id;

      await prisma.notification.deleteMany({
        where: { id, userId },
      });

      res.status(204).send();
    } catch (error) {
      next(error);
    }
  },
};
```

### Notification Bell Component
```typescript
'use client';

import { useEffect, useState } from 'react';
import { Bell } from 'lucide-react';

export function NotificationBell() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [open, setOpen] = useState(false);

  useEffect(() => {
    fetchNotifications();

    // Poll for new notifications every 30 seconds
    const interval = setInterval(fetchNotifications, 30000);

    return () => clearInterval(interval);
  }, []);

  const fetchNotifications = async () => {
    const response = await fetch('/api/notifications?limit=10');
    const { notifications, unreadCount } = await response.json();

    setNotifications(notifications);
    setUnreadCount(unreadCount);
  };

  const handleNotificationClick = async (notification: Notification) => {
    // Mark as read
    await fetch(`/api/notifications/${notification.id}/read`, {
      method: 'PATCH',
    });

    // Navigate to link
    if (notification.link) {
      window.location.href = notification.link;
    }

    setOpen(false);
    fetchNotifications();
  };

  const handleMarkAllRead = async () => {
    await fetch('/api/notifications/mark-all-read', {
      method: 'POST',
    });

    fetchNotifications();
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen}>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon" className="relative">
          <Bell className="h-5 w-5" />
          {unreadCount > 0 && (
            <span className="absolute top-0 right-0 h-4 w-4 bg-red-500 text-white text-xs rounded-full flex items-center justify-center">
              {unreadCount > 9 ? '9+' : unreadCount}
            </span>
          )}
        </Button>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="end" className="w-80">
        <div className="flex items-center justify-between p-2 border-b border-gray-800">
          <h3 className="font-bold">Notifications</h3>
          {unreadCount > 0 && (
            <Button
              variant="ghost"
              size="sm"
              onClick={handleMarkAllRead}
            >
              Mark all read
            </Button>
          )}
        </div>

        <div className="max-h-[400px] overflow-y-auto">
          {notifications.length === 0 ? (
            <div className="p-8 text-center text-gray-400">
              <Bell className="h-12 w-12 mx-auto mb-2 opacity-50" />
              <p>No notifications</p>
            </div>
          ) : (
            notifications.map((notification) => (
              <div
                key={notification.id}
                className={`p-3 border-b border-gray-800 cursor-pointer hover:bg-gray-900 ${
                  !notification.read ? 'bg-blue-500/10' : ''
                }`}
                onClick={() => handleNotificationClick(notification)}
              >
                <div className="flex items-start gap-2">
                  {!notification.read && (
                    <div className="w-2 h-2 bg-blue-500 rounded-full mt-1" />
                  )}
                  <div className="flex-1">
                    <p className="font-medium text-sm">{notification.title}</p>
                    <p className="text-xs text-gray-400 line-clamp-2">
                      {notification.message}
                    </p>
                    <p className="text-xs text-gray-400 mt-1">
                      {formatDistanceToNow(new Date(notification.createdAt), {
                        addSuffix: true,
                      })}
                    </p>
                  </div>
                </div>
              </div>
            ))
          )}
        </div>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```

### Notification Preferences Page
```typescript
export default function NotificationSettingsPage() {
  const [settings, setSettings] = useState({
    email: true,
    types: ['turn_start', 'message', 'dice_roll', 'combat_start'],
  });

  const handleSave = async () => {
    await fetch('/api/users/me/notification-settings', {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ notificationSettings: settings }),
    });

    toast.success('Notification settings saved!');
  };

  return (
    <div className="container max-w-2xl mx-auto py-12">
      <h1 className="text-h1 font-bold mb-6">Notification Settings</h1>

      <Card className="p-6 space-y-6">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="font-medium">Email Notifications</h3>
            <p className="text-sm text-gray-400">
              Receive emails for important events
            </p>
          </div>
          <Switch
            checked={settings.email}
            onCheckedChange={(checked) =>
              setSettings({ ...settings, email: checked })
            }
          />
        </div>

        <Separator />

        <div className="space-y-4">
          <h3 className="font-medium">Notification Types</h3>

          {[
            { value: 'turn_start', label: 'Turn Start', desc: 'When it\'s your turn in async games' },
            { value: 'message', label: 'New Messages', desc: 'When someone posts in your tables' },
            { value: 'dice_roll', label: 'Dice Rolls', desc: 'When someone rolls dice' },
            { value: 'combat_start', label: 'Combat Start', desc: 'When combat begins' },
          ].map((type) => (
            <div key={type.value} className="flex items-center gap-3">
              <Checkbox
                checked={settings.types.includes(type.value)}
                onCheckedChange={(checked) => {
                  const newTypes = checked
                    ? [...settings.types, type.value]
                    : settings.types.filter((t) => t !== type.value);
                  setSettings({ ...settings, types: newTypes });
                }}
              />
              <div>
                <p className="text-sm font-medium">{type.label}</p>
                <p className="text-xs text-gray-400">{type.desc}</p>
              </div>
            </div>
          ))}
        </div>

        <Button onClick={handleSave} className="w-full">
          Save Settings
        </Button>
      </Card>
    </div>
  );
}
```

### Testing

**Test scenarios:**
- Email sent when async turn starts
- Email includes table name, deadline, link
- In-app notification created for turn start
- Bell icon shows unread count
- Clicking notification marks as read
- Notification preferences save correctly
- Email only sent if user has email enabled
- Notification types filter correctly
- "Mark all as read" works
- Notifications deleted when clicked

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
