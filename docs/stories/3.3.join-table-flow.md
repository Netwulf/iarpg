# Story 3.3: Join Table Flow (Invite + Character Selection)

## Status
Draft

## Story
**As a** User,
**I want** to join tables by entering an invite code or browsing public tables, and select which character I'll play,
**so that** I can participate in RPG sessions with my chosen character.

## Acceptance Criteria
1. User can join table via invite code at `/tables/join`
2. User can join table from browse page by clicking "Join Table" button
3. Join flow validates table has available slots (playerCount < maxPlayers)
4. Join flow requires selecting an existing character (or creating one)
5. User cannot join same table twice
6. After joining, user is redirected to table page `/tables/{id}`
7. Table owner receives notification when someone joins
8. Private tables require invite code, public tables allow direct join

## Tasks / Subtasks

- [ ] Create invite code join page (AC: 1)
  - [ ] Create `/tables/join` route
  - [ ] Add "Join with Invite Code" link in navigation
  - [ ] Create form with invite code input (6-char alphanumeric)
  - [ ] Add "Join Table" submit button
  - [ ] Handle loading and error states

- [ ] Implement invite code validation (AC: 1, 8)
  - [ ] Format input to uppercase (ABC123)
  - [ ] Validate 6-character alphanumeric pattern
  - [ ] Fetch table details: GET `/api/tables/by-code/{code}`
  - [ ] Show error if code invalid or table not found
  - [ ] Redirect to character selection if valid

- [ ] Add join button to browse page (AC: 2)
  - [ ] Add "Join Table" button to TableCard component
  - [ ] Show button only for public/spectator tables
  - [ ] Hide button if table is full or user already member
  - [ ] Click triggers join flow (character selection modal)

- [ ] Create character selection modal (AC: 4)
  - [ ] Display user's characters in grid (2 columns)
  - [ ] Show character name, race, class, level
  - [ ] Add "Select" button for each character
  - [ ] Add "Create New Character" link → `/characters/new?returnTo=/tables/{id}`
  - [ ] Show empty state if user has no characters

- [ ] Validate table availability (AC: 3)
  - [ ] Check `playerCount < maxPlayers`
  - [ ] Return 400 if table is full
  - [ ] Show user-friendly error: "Table is full (6/6 players)"
  - [ ] Suggest browsing other tables

- [ ] Validate duplicate membership (AC: 5)
  - [ ] Check if user is already a table member
  - [ ] Return 400 if already joined
  - [ ] Show message: "You are already a member of this table"
  - [ ] Redirect to table page if already member

- [ ] Create join table API endpoint (AC: 3, 5, 8)
  - [ ] POST `/api/tables/{id}/join`
  - [ ] Validate table exists and is joinable
  - [ ] Validate user has selected character
  - [ ] Check table availability (not full)
  - [ ] Check user not already member
  - [ ] Create TableMember record with role "player"
  - [ ] Return updated table with members

- [ ] Handle private table privacy (AC: 8)
  - [ ] Private tables: require valid invite code
  - [ ] Public tables: allow direct join from browse
  - [ ] Spectator tables: allow join as spectator (no character)
  - [ ] Validate privacy level in API

- [ ] Handle post-join redirect (AC: 6)
  - [ ] After successful join, redirect to `/tables/{id}`
  - [ ] Show success toast: "Joined table! Welcome to {tableName}"
  - [ ] Scroll to table chat or overview section

- [ ] Implement join notification (AC: 7)
  - [ ] Send Socket.io event to table owner: `table:member-joined`
  - [ ] Emit event data: `{ tableId, newMember: { username, character } }`
  - [ ] Display toast notification to DM
  - [ ] Update table member list in real-time

- [ ] Add spectator join option (AC: 8)
  - [ ] For spectator tables, add "Join as Spectator" button
  - [ ] Spectators don't need a character
  - [ ] Create TableMember with role "spectator" and characterId null
  - [ ] Spectators can view but not interact with game

## Dev Notes

### Join Flow Diagram
**[Source: PRD Section 3.4.3 - Join Table Flow]**

```
┌─────────────────────────────────────┐
│ USER ENTRY POINT                    │
│                                     │
│ Option 1: Enter invite code         │
│   /tables/join                      │
│   [ABC123]  [Join]                  │
│                                     │
│ Option 2: Browse public tables      │
│   /tables/browse                    │
│   [Table Card]  [Join Table]        │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ VALIDATE TABLE                      │
│ - Table exists?                     │
│ - Privacy allows join?              │
│ - Table has available slots?        │
│ - User not already member?          │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ CHARACTER SELECTION MODAL           │
│                                     │
│ Select a character to play:         │
│                                     │
│ ┌─────────┐  ┌─────────┐           │
│ │ Thorin  │  │ Elara   │           │
│ │ Fighter │  │ Wizard  │           │
│ │ Lvl 5   │  │ Lvl 3   │           │
│ │ [Select]│  │ [Select]│           │
│ └─────────┘  └─────────┘           │
│                                     │
│ [Create New Character]              │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ JOIN TABLE                          │
│ POST /api/tables/{id}/join          │
│ { characterId: "clxxx" }            │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ REDIRECT TO TABLE                   │
│ /tables/{id}                        │
│ Toast: "Joined table!"              │
│                                     │
│ Socket.io: Notify DM                │
└─────────────────────────────────────┘
```

### Invite Code Join Page
```typescript
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { Input } from '@iarpg/ui/input';
import { Button } from '@iarpg/ui/button';
import { Card } from '@iarpg/ui/card';

export default function JoinTablePage() {
  const [code, setCode] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    const normalizedCode = code.toUpperCase().replace(/\s/g, '');

    if (!/^[A-Z0-9]{6}$/.test(normalizedCode)) {
      setError('Invite code must be 6 alphanumeric characters');
      setLoading(false);
      return;
    }

    try {
      const response = await fetch(`/api/tables/by-code/${normalizedCode}`);

      if (!response.ok) {
        throw new Error('Invalid invite code');
      }

      const { table } = await response.json();

      // Redirect to character selection with table ID
      router.push(`/tables/${table.id}/join`);
    } catch (err) {
      setError('Invalid invite code. Please check and try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container max-w-md mx-auto py-12">
      <Card className="p-8">
        <h1 className="text-h1 font-bold mb-2">Join Table</h1>
        <p className="text-body text-gray-400 mb-6">
          Enter the 6-character invite code shared by the table owner
        </p>

        <form onSubmit={handleSubmit} className="space-y-4">
          <Input
            type="text"
            placeholder="ABC123"
            value={code}
            onChange={(e) => setCode(e.target.value)}
            maxLength={6}
            className="text-center text-2xl tracking-widest uppercase"
            disabled={loading}
          />

          {error && (
            <p className="text-small text-red">{error}</p>
          )}

          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? 'Validating...' : 'Join Table'}
          </Button>
        </form>

        <div className="mt-6 text-center">
          <p className="text-small text-gray-400 mb-2">Don't have an invite code?</p>
          <Button variant="link" asChild>
            <Link href="/tables/browse">Browse Public Tables</Link>
          </Button>
        </div>
      </Card>
    </div>
  );
}
```

### Character Selection Modal
```typescript
interface CharacterSelectionModalProps {
  tableId: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  characters: Character[];
}

function CharacterSelectionModal({
  tableId,
  open,
  onOpenChange,
  characters,
}: CharacterSelectionModalProps) {
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleSelectCharacter = async (characterId: string) => {
    setLoading(true);

    try {
      const response = await fetch(`/api/tables/${tableId}/join`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ characterId }),
      });

      if (!response.ok) {
        const { error } = await response.json();
        throw new Error(error);
      }

      const { table } = await response.json();

      toast.success(`Joined table! Welcome to ${table.name}`);
      router.push(`/tables/${tableId}`);
    } catch (error) {
      toast.error(error.message || 'Failed to join table');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Select a Character</DialogTitle>
        </DialogHeader>

        {characters.length === 0 ? (
          <div className="text-center py-8">
            <p className="text-body text-gray-400 mb-4">
              You need a character to join this table.
            </p>
            <Button asChild>
              <Link href={`/characters/new?returnTo=/tables/${tableId}/join`}>
                Create Character
              </Link>
            </Button>
          </div>
        ) : (
          <div className="grid grid-cols-2 gap-4">
            {characters.map((character) => (
              <Card
                key={character.id}
                className="p-4 hover:border-green-neon transition-colors"
              >
                <div className="flex items-start gap-3 mb-3">
                  <Avatar className="h-12 w-12">
                    <AvatarImage src={character.avatarUrl} />
                    <AvatarFallback>{character.name[0]}</AvatarFallback>
                  </Avatar>
                  <div className="flex-1">
                    <h3 className="font-bold">{character.name}</h3>
                    <p className="text-small text-gray-400">
                      Level {character.level} {character.race} {character.class}
                    </p>
                  </div>
                </div>

                <Button
                  className="w-full"
                  onClick={() => handleSelectCharacter(character.id)}
                  disabled={loading}
                >
                  Select
                </Button>
              </Card>
            ))}
          </div>
        )}

        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

### API Endpoints
**[Source: Architecture Section 5.1.4]**

```typescript
// GET /api/tables/by-code/:code
export const tablesController = {
  async getByCode(req: Request, res: Response, next: NextFunction) {
    try {
      const { code } = req.params;

      const table = await prisma.table.findUnique({
        where: { inviteCode: code.toUpperCase() },
        include: {
          owner: {
            select: { username: true, avatar: true },
          },
          members: {
            select: { id: true },
          },
        },
      });

      if (!table) {
        return res.status(404).json({ error: 'Invalid invite code' });
      }

      // Don't reveal private table details to non-members
      if (table.privacy === 'private') {
        return res.json({
          table: {
            id: table.id,
            name: table.name,
            privacy: table.privacy,
          },
        });
      }

      res.json({ table });
    } catch (error) {
      next(error);
    }
  },

  // POST /api/tables/:id/join
  async join(req: Request, res: Response, next: NextFunction) {
    try {
      const { id } = req.params;
      const userId = req.user!.id;
      const { characterId, asSpectator } = req.body;

      // Fetch table
      const table = await prisma.table.findUnique({
        where: { id },
        include: {
          members: true,
        },
      });

      if (!table) {
        return res.status(404).json({ error: 'Table not found' });
      }

      // Check if table is joinable
      if (table.state === 'completed') {
        return res.status(400).json({ error: 'Table is completed' });
      }

      // Check if user is already a member
      const existingMember = table.members.find((m) => m.userId === userId);
      if (existingMember) {
        return res.status(400).json({ error: 'You are already a member of this table' });
      }

      // Check table capacity (skip for spectators)
      if (!asSpectator && table.members.length >= table.maxPlayers) {
        return res.status(400).json({
          error: `Table is full (${table.members.length}/${table.maxPlayers} players)`,
        });
      }

      // Validate character ownership (skip for spectators)
      if (!asSpectator) {
        const character = await prisma.character.findUnique({
          where: { id: characterId },
        });

        if (!character || character.userId !== userId) {
          return res.status(403).json({ error: 'Invalid character' });
        }
      }

      // Create table membership
      const member = await prisma.tableMember.create({
        data: {
          tableId: id,
          userId,
          characterId: asSpectator ? null : characterId,
          role: asSpectator ? 'spectator' : 'player',
          status: 'active',
        },
        include: {
          user: {
            select: { username: true, avatar: true },
          },
          character: {
            select: { name: true, race: true, class: true, level: true },
          },
        },
      });

      // Update table lastActivityAt
      await prisma.table.update({
        where: { id },
        data: { lastActivityAt: new Date() },
      });

      // Emit Socket.io event to table owner and members
      req.io.to(`table:${id}`).emit('table:member-joined', {
        tableId: id,
        member,
      });

      res.status(201).json({ member });
    } catch (error) {
      next(error);
    }
  },
};
```

### Socket.io Event Handling
**[Source: Architecture Section 5.3 - Socket.io Events]**

```typescript
// apps/api/src/socket/tables.socket.ts
export function setupTableSocket(io: SocketIOServer) {
  io.on('connection', (socket) => {
    // Join table room
    socket.on('table:join-room', (tableId: string) => {
      socket.join(`table:${tableId}`);
    });

    // Leave table room
    socket.on('table:leave-room', (tableId: string) => {
      socket.leave(`table:${tableId}`);
    });
  });
}

// Client-side listener
useEffect(() => {
  if (!socket) return;

  socket.on('table:member-joined', ({ tableId, member }) => {
    if (user.id === table.ownerId) {
      toast.success(`${member.user.username} joined the table!`);
    }

    // Update member list
    setMembers((prev) => [...prev, member]);
  });

  return () => {
    socket.off('table:member-joined');
  };
}, [socket]);
```

### Enhanced TableCard with Join Button
```typescript
function TableCard({ table, currentUserId }: TableCardProps) {
  const [showCharacterSelect, setShowCharacterSelect] = useState(false);
  const isFull = table.playerCount >= table.maxPlayers;
  const isAlreadyMember = table.members?.some((m) => m.userId === currentUserId);

  return (
    <Card className="p-4">
      {/* ... existing card content ... */}

      <div className="flex gap-2">
        <Button asChild variant="outline" className="flex-1">
          <Link href={`/tables/${table.id}`}>View</Link>
        </Button>

        {table.privacy !== 'private' && !isAlreadyMember && (
          <Button
            className="flex-1"
            disabled={isFull}
            onClick={() => setShowCharacterSelect(true)}
          >
            {isFull ? 'Full' : 'Join'}
          </Button>
        )}
      </div>

      <CharacterSelectionModal
        tableId={table.id}
        open={showCharacterSelect}
        onOpenChange={setShowCharacterSelect}
        characters={userCharacters}
      />
    </Card>
  );
}
```

### Spectator Join Flow
```typescript
// For spectator tables, add "Join as Spectator" option
function SpectatorJoinButton({ tableId }: { tableId: string }) {
  const handleJoinAsSpectator = async () => {
    try {
      const response = await fetch(`/api/tables/${tableId}/join`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ asSpectator: true }),
      });

      if (!response.ok) {
        throw new Error('Failed to join as spectator');
      }

      toast.success('Joined as spectator!');
      router.push(`/tables/${tableId}`);
    } catch (error) {
      toast.error(error.message);
    }
  };

  return (
    <Button variant="outline" onClick={handleJoinAsSpectator}>
      Join as Spectator
    </Button>
  );
}
```

### Testing

**Test scenarios:**
- User can join table with valid invite code
- User can join public table from browse page
- User cannot join table if already a member
- User cannot join table if it's full
- Character selection modal displays user's characters
- User can create new character from join flow
- Table owner receives notification when someone joins
- Private tables require valid invite code
- Public tables allow direct join
- Spectator tables allow joining as spectator
- Join redirects to table page after success
- Real-time member list updates via Socket.io

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
