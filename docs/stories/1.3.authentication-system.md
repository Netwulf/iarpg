# Story 1.3: Authentication System (NextAuth.js + Supabase Auth)

## Status
Draft

## Story
**As a** Developer,
**I want** to implement a complete authentication system with email/password and OAuth providers using NextAuth.js integrated with Supabase,
**so that** users can securely register, login, and access protected features throughout the application.

## Acceptance Criteria
1. NextAuth.js v5 is installed and configured in `apps/web`
2. Email/password authentication (credentials provider) is functional with bcrypt password hashing
3. OAuth providers (Google, Discord) are configured and functional
4. Authentication API routes (`/api/auth/*`) are working in Next.js App Router
5. Session management is implemented with JWT tokens stored in httpOnly cookies
6. Protected routes and API endpoints require valid authentication
7. User registration creates records in Supabase database via Prisma
8. Login flow validates credentials and returns session

## Tasks / Subtasks

- [ ] Install and configure NextAuth.js v5 (AC: 1)
  - [ ] Run `pnpm add next-auth@beta bcryptjs` in apps/web
  - [ ] Run `pnpm add -D @types/bcryptjs` in apps/web
  - [ ] Create `apps/web/src/app/api/auth/[...nextauth]/route.ts`
  - [ ] Create `apps/web/src/lib/auth.ts` for NextAuth configuration
  - [ ] Generate NEXTAUTH_SECRET using `openssl rand -base64 32`
  - [ ] Add NEXTAUTH_URL and NEXTAUTH_SECRET to .env.local

- [ ] Configure Credentials Provider (email/password) (AC: 2, 7, 8)
  - [ ] Create credentials provider in auth.ts
  - [ ] Implement authorize function to validate email/password
  - [ ] Query Prisma to find user by email
  - [ ] Verify password using bcrypt.compare()
  - [ ] Return user object on successful authentication
  - [ ] Return null on failed authentication

- [ ] Configure Google OAuth Provider (AC: 3)
  - [ ] Create Google Cloud Console project
  - [ ] Enable Google OAuth API
  - [ ] Create OAuth 2.0 credentials (Client ID + Secret)
  - [ ] Add authorized redirect URI: `http://localhost:3000/api/auth/callback/google`
  - [ ] Add GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET to .env.local
  - [ ] Configure GoogleProvider in auth.ts

- [ ] Configure Discord OAuth Provider (AC: 3)
  - [ ] Create Discord application at https://discord.com/developers
  - [ ] Add OAuth2 redirect: `http://localhost:3000/api/auth/callback/discord`
  - [ ] Copy Client ID and Client Secret
  - [ ] Add DISCORD_CLIENT_ID and DISCORD_CLIENT_SECRET to .env.local
  - [ ] Configure DiscordProvider in auth.ts

- [ ] Implement User Registration Flow (AC: 7)
  - [ ] Create `/api/auth/register` API route in apps/web
  - [ ] Validate input (email format, username unique, password strength)
  - [ ] Hash password with bcrypt (12 rounds)
  - [ ] Create user in database using Prisma
  - [ ] Return success response with user data
  - [ ] Handle duplicate email/username errors

- [ ] Configure NextAuth Session Strategy (AC: 5)
  - [ ] Set session strategy to "jwt" in auth.ts
  - [ ] Configure JWT token with user id, email, username, tier
  - [ ] Set session maxAge to 30 days
  - [ ] Enable httpOnly cookies for token storage
  - [ ] Configure callbacks: jwt(), session()

- [ ] Create Authentication UI Components (AC: 2, 3)
  - [ ] Create Login page at `apps/web/src/app/login/page.tsx`
  - [ ] Create Register page at `apps/web/src/app/register/page.tsx`
  - [ ] Add email/password form inputs with validation
  - [ ] Add "Sign in with Google" button
  - [ ] Add "Sign in with Discord" button
  - [ ] Handle loading states and error messages
  - [ ] Redirect to dashboard after successful login

- [ ] Implement Protected Route Middleware (AC: 6)
  - [ ] Create `apps/web/src/middleware.ts` for route protection
  - [ ] Check authentication status using NextAuth getServerSession
  - [ ] Redirect unauthenticated users to /login
  - [ ] Define protected paths (dashboard, tables, characters, etc.)
  - [ ] Define public paths (login, register, landing)

- [ ] Create Authentication Helper Functions (AC: 6)
  - [ ] Create `apps/web/src/lib/auth-helpers.ts`
  - [ ] Export `getServerSession()` wrapper for server components
  - [ ] Export `requireAuth()` helper that throws if not authenticated
  - [ ] Export `getCurrentUser()` helper that returns current user or null

- [ ] Implement Logout Functionality (AC: 8)
  - [ ] Create logout button component
  - [ ] Call NextAuth signOut() function
  - [ ] Clear session cookie
  - [ ] Redirect to landing page

- [ ] Create Backend Auth Middleware for Express API (AC: 6)
  - [ ] Create `apps/api/src/middleware/auth.middleware.ts`
  - [ ] Verify JWT token from Authorization header
  - [ ] Decode token and extract user id
  - [ ] Attach user to request object (req.user)
  - [ ] Return 401 Unauthorized if token invalid/missing

- [ ] Test Authentication Flows (AC: 2, 3, 7, 8)
  - [ ] Test user registration with email/password
  - [ ] Test login with valid credentials
  - [ ] Test login with invalid credentials (should fail)
  - [ ] Test Google OAuth flow
  - [ ] Test Discord OAuth flow
  - [ ] Test logout clears session
  - [ ] Test protected routes require authentication
  - [ ] Test API endpoints require valid JWT

- [ ] Update Environment Variables Documentation (AC: 1, 3)
  - [ ] Update `.env.example` with all auth-related variables
  - [ ] Document how to obtain Google OAuth credentials
  - [ ] Document how to obtain Discord OAuth credentials
  - [ ] Update README with authentication setup instructions

## Dev Notes

### NextAuth.js v5 Configuration
**[Source: Architecture Section 3 - Tech Stack]**

**Version:** NextAuth.js **5.0.0-beta+** (latest beta, stable v4 not compatible with App Router)

**Why NextAuth.js v5:**
- Native Next.js App Router support
- TypeScript-first design
- JWT + Database session strategies
- Built-in OAuth provider integrations (Google, Discord, GitHub, etc.)
- Integrates with Supabase for user storage

**Installation:**
```bash
cd apps/web
pnpm add next-auth@beta bcryptjs
pnpm add -D @types/bcryptjs
```

### NextAuth.js Configuration File
**[Source: NextAuth.js v5 docs + Architecture Section 10]**

**`apps/web/src/lib/auth.ts` (COPY-PASTE READY):**
```typescript
import NextAuth, { NextAuthConfig } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import GoogleProvider from 'next-auth/providers/google';
import DiscordProvider from 'next-auth/providers/discord';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from '@iarpg/db';
import bcrypt from 'bcryptjs';

export const authConfig: NextAuthConfig = {
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  pages: {
    signIn: '/login',
    signOut: '/login',
    error: '/login',
  },
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email as string },
        });

        if (!user || !user.passwordHash) {
          return null;
        }

        const isPasswordValid = await bcrypt.compare(
          credentials.password as string,
          user.passwordHash
        );

        if (!isPasswordValid) {
          return null;
        }

        return {
          id: user.id,
          email: user.email,
          username: user.username,
          tier: user.tier,
        };
      },
    }),
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    DiscordProvider({
      clientId: process.env.DISCORD_CLIENT_ID!,
      clientSecret: process.env.DISCORD_CLIENT_SECRET!,
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.username = user.username;
        token.tier = user.tier;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
        session.user.username = token.username as string;
        session.user.tier = token.tier as string;
      }
      return session;
    },
  },
};

export const { handlers, auth, signIn, signOut } = NextAuth(authConfig);
```

### NextAuth API Route
**[Source: Next.js App Router conventions]**

**`apps/web/src/app/api/auth/[...nextauth]/route.ts`:**
```typescript
import { handlers } from '@/lib/auth';

export const { GET, POST } = handlers;
```

**Note:** NextAuth v5 uses route handlers, not API routes. This file exports GET/POST handlers for all auth endpoints (/api/auth/*).

### User Registration Endpoint
**[Source: Architecture Section 5.1.1 - Authentication Endpoints]**

**`apps/web/src/app/api/auth/register/route.ts`:**
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@iarpg/db';
import bcrypt from 'bcryptjs';
import { z } from 'zod';

const registerSchema = z.object({
  email: z.string().email('Invalid email format'),
  username: z.string().min(3, 'Username must be at least 3 characters').max(20),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { email, username, password } = registerSchema.parse(body);

    // Check if email already exists
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [{ email }, { username }],
      },
    });

    if (existingUser) {
      return NextResponse.json(
        { error: 'Email or username already exists' },
        { status: 400 }
      );
    }

    // Hash password
    const passwordHash = await bcrypt.hash(password, 12);

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        username,
        passwordHash,
        tier: 'free',
      },
      select: {
        id: true,
        email: true,
        username: true,
        tier: true,
        createdAt: true,
      },
    });

    return NextResponse.json({ user }, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }

    console.error('Registration error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Protected Route Middleware
**[Source: Next.js App Router middleware + Architecture]**

**`apps/web/src/middleware.ts`:**
```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { auth } from '@/lib/auth';

export async function middleware(request: NextRequest) {
  const session = await auth();

  const isAuthPage = request.nextUrl.pathname.startsWith('/login') ||
                     request.nextUrl.pathname.startsWith('/register');

  const isProtectedRoute =
    request.nextUrl.pathname.startsWith('/dashboard') ||
    request.nextUrl.pathname.startsWith('/tables') ||
    request.nextUrl.pathname.startsWith('/characters') ||
    request.nextUrl.pathname.startsWith('/profile');

  // Redirect authenticated users away from auth pages
  if (isAuthPage && session) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  // Redirect unauthenticated users to login
  if (isProtectedRoute && !session) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
```

### Backend API Auth Middleware (Express)
**[Source: Architecture Section 11.3 - Backend Middleware]**

**`apps/api/src/middleware/auth.middleware.ts`:**
```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface JWTPayload {
  id: string;
  email: string;
  username: string;
  tier: string;
}

declare global {
  namespace Express {
    interface Request {
      user?: JWTPayload;
    }
  }
}

export const authMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized - No token provided' });
  }

  const token = authHeader.substring(7);

  try {
    const decoded = jwt.verify(
      token,
      process.env.NEXTAUTH_SECRET!
    ) as JWTPayload;

    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Unauthorized - Invalid token' });
  }
};
```

**Usage in Express routes:**
```typescript
import { authMiddleware } from '../middleware/auth.middleware';

router.get('/api/characters', authMiddleware, charactersController.getAll);
```

### Authentication Helper Functions
**[Source: Best practices for Next.js App Router]**

**`apps/web/src/lib/auth-helpers.ts`:**
```typescript
import { auth } from './auth';
import { redirect } from 'next/navigation';

/**
 * Get current session (server components only)
 */
export async function getServerSession() {
  return await auth();
}

/**
 * Require authentication - throws/redirects if not authenticated
 */
export async function requireAuth() {
  const session = await auth();
  if (!session) {
    redirect('/login');
  }
  return session;
}

/**
 * Get current user or null
 */
export async function getCurrentUser() {
  const session = await auth();
  return session?.user ?? null;
}
```

### OAuth Provider Setup Instructions

**Google OAuth:**
**[Source: Google Cloud Console setup]**

1. Go to https://console.cloud.google.com/
2. Create new project: "IA-RPG"
3. Enable "Google+ API"
4. Navigate to "Credentials" → "Create Credentials" → "OAuth 2.0 Client ID"
5. Application type: "Web application"
6. Authorized redirect URIs:
   - Development: `http://localhost:3000/api/auth/callback/google`
   - Production: `https://iarpg.com/api/auth/callback/google`
7. Copy Client ID and Client Secret
8. Add to `.env.local`:
   ```bash
   GOOGLE_CLIENT_ID="your-client-id.apps.googleusercontent.com"
   GOOGLE_CLIENT_SECRET="your-client-secret"
   ```

**Discord OAuth:**
**[Source: Discord Developer Portal setup]**

1. Go to https://discord.com/developers/applications
2. Click "New Application" → Name: "IA-RPG"
3. Navigate to "OAuth2" tab
4. Add redirect:
   - Development: `http://localhost:3000/api/auth/callback/discord`
   - Production: `https://iarpg.com/api/auth/callback/discord`
5. Copy Client ID and Client Secret
6. Add to `.env.local`:
   ```bash
   DISCORD_CLIENT_ID="your-application-id"
   DISCORD_CLIENT_SECRET="your-client-secret"
   ```

### Environment Variables
**[Source: Architecture Section 14.2 - Deployment]**

**`apps/web/.env.local`:**
```bash
# NextAuth.js
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-secret-generated-with-openssl-rand-base64-32"

# Google OAuth
GOOGLE_CLIENT_ID="xxx.apps.googleusercontent.com"
GOOGLE_CLIENT_SECRET="GOCSPX-xxx"

# Discord OAuth
DISCORD_CLIENT_ID="xxx"
DISCORD_CLIENT_SECRET="xxx"

# Supabase (from Story 1.2)
NEXT_PUBLIC_SUPABASE_URL="https://xxxxx.supabase.co"
NEXT_PUBLIC_SUPABASE_ANON_KEY="eyJhbGc..."
```

**`apps/api/.env`:**
```bash
# NextAuth Secret (must match frontend)
NEXTAUTH_SECRET="same-secret-as-frontend"
```

**Generate NEXTAUTH_SECRET:**
```bash
openssl rand -base64 32
```

### Password Security
**[Source: Architecture Section 15.1 - Security]**

**Hashing Strategy:**
- Algorithm: **bcrypt**
- Rounds: **12** (balances security and performance)
- Never store plain text passwords
- Never return passwordHash in API responses

**Password Requirements:**
- Minimum 8 characters
- Must contain at least: 1 uppercase, 1 lowercase, 1 number (optional for MVP, can add with Zod later)

### Session Management
**[Source: Architecture Section 15.1]**

**JWT Token Configuration:**
- Storage: **httpOnly cookies** (XSS protection)
- MaxAge: **30 days**
- SameSite: **lax** (CSRF protection)
- Secure: **true** in production (HTTPS only)

**Token Payload:**
```typescript
{
  id: string;
  email: string;
  username: string;
  tier: 'free' | 'premium' | 'master';
  iat: number; // Issued at
  exp: number; // Expires at
}
```

### Login Page Example
**[Source: Front-End Spec Section 5.2 - Wireframes]**

**`apps/web/src/app/login/page.tsx`:**
```typescript
'use client';

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { Button } from '@iarpg/ui/components/button';
import { Input } from '@iarpg/ui/components/input';

export default function LoginPage() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    const result = await signIn('credentials', {
      email,
      password,
      redirect: false,
    });

    setLoading(false);

    if (result?.error) {
      setError('Invalid email or password');
    } else {
      router.push('/dashboard');
      router.refresh();
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="w-full max-w-md space-y-8 p-8">
        <h1 className="text-3xl font-bold">Login to IA-RPG</h1>

        <form onSubmit={handleSubmit} className="space-y-4">
          <Input
            type="email"
            placeholder="Email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
          <Input
            type="password"
            placeholder="Password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />

          {error && <p className="text-red-500 text-sm">{error}</p>}

          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? 'Signing in...' : 'Sign In'}
          </Button>
        </form>

        <div className="space-y-2">
          <Button
            onClick={() => signIn('google', { callbackUrl: '/dashboard' })}
            variant="outline"
            className="w-full"
          >
            Continue with Google
          </Button>
          <Button
            onClick={() => signIn('discord', { callbackUrl: '/dashboard' })}
            variant="outline"
            className="w-full"
          >
            Continue with Discord
          </Button>
        </div>

        <p className="text-center text-sm">
          Don't have an account?{' '}
          <a href="/register" className="text-green-neon hover:underline">
            Register
          </a>
        </p>
      </div>
    </div>
  );
}
```

### Testing

**Test Framework:** Vitest + Playwright
**Test File Location:**
- Unit: `apps/web/tests/auth.test.ts`
- E2E: `apps/web/tests/e2e/auth.spec.ts`

**Testing Standards:**
**[Source: Architecture Section 16 - Testing Strategy]**

**Unit Tests:**
- Test password hashing and verification
- Test JWT token generation and validation
- Test auth middleware rejects invalid tokens
- Test registration endpoint validates input

**E2E Tests:**
- Test user can register with email/password
- Test user can login with valid credentials
- Test user cannot login with invalid credentials
- Test user can login with Google OAuth
- Test user can login with Discord OAuth
- Test protected routes redirect to login
- Test logout clears session

**Sample E2E test (Playwright):**
```typescript
import { test, expect } from '@playwright/test';

test.describe('Authentication', () => {
  test('should register new user', async ({ page }) => {
    await page.goto('/register');
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="username"]', 'testuser');
    await page.fill('[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('should login existing user', async ({ page }) => {
    await page.goto('/login');
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('should reject invalid credentials', async ({ page }) => {
    await page.goto('/login');
    await page.fill('[name="email"]', 'test@example.com');
    await page.fill('[name="password"]', 'wrongpassword');
    await page.click('button[type="submit"]');
    await expect(page.locator('text=Invalid email or password')).toBeVisible();
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be filled by dev agent_

### Debug Log References
_To be filled by dev agent_

### Completion Notes List
_To be filled by dev agent_

### File List
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
