# Story 4.3: Typing Indicators & Presence System

## Status
In Progress (Typing indicators complete, presence tracking pending database)

## Story
**As a** Table Member,
**I want** to see who is currently online and when someone is typing,
**so that** I know who is active and engaged in the conversation.

## Acceptance Criteria
1. Member list shows online status (green dot) for connected members
2. Member list shows "typing..." indicator when someone is typing
3. Typing indicator appears below chat input: "Alice is typing..."
4. Typing indicator clears after 3 seconds of inactivity
5. Multiple users typing shows: "Alice, Bob, and Carol are typing..."
6. Online status updates in real-time via Socket.io
7. User status changes to offline after disconnect or 30s timeout
8. Presence persists across page refreshes (stored in database)

## Tasks / Subtasks

- [ ] Implement online status tracking (AC: 1, 6)
  - [x] Emit `user:online` event when socket connects
  - [ ] Server updates user status to "online" in database (needs DB)
  - [ ] Broadcast `presence:update` to relevant table rooms (needs DB)
  - [ ] Client updates member list with online status (needs DB)
  - [ ] Show green dot for online, gray for offline (needs DB)

- [ ] Implement offline status tracking (AC: 7)
  - [ ] Emit `user:offline` event on socket disconnect (needs DB)
  - [ ] Server updates user status to "offline" in database (needs DB)
  - [ ] Set 30-second timeout before marking offline (implemented on server)
  - [ ] Broadcast `presence:update` to table rooms (needs DB)
  - [ ] Client updates member list (needs DB)

- [x] Create typing indicator system (AC: 2, 3, 4)
  - [x] Emit `typing:start` when user types in chat input
  - [x] Throttle emit (only emit every 500ms)
  - [x] Server broadcasts `typing:start` to table room
  - [x] Client shows "Alice is typing..." below chat
  - [x] Auto-hide after 3 seconds if no `typing:stop` received

- [x] Handle typing stop event (AC: 4)
  - [x] Emit `typing:stop` when user stops typing (3s idle)
  - [x] Emit `typing:stop` when message is sent
  - [x] Server broadcasts `typing:stop` to table room
  - [x] Client removes typing indicator

- [x] Handle multiple users typing (AC: 5)
  - [x] Track list of currently typing users
  - [x] Format display: "Alice is typing..."
  - [x] Format for 2 users: "Alice and Bob are typing..."
  - [x] Format for 3+: "Alice, Bob, and Carol are typing..."
  - [x] Limit display to first 3 users, show "+N others" if needed

- [ ] Create presence database tracking (AC: 8)
  - [ ] Add `onlineStatus` and `lastSeenAt` to User model
  - [ ] Update on `user:online` event
  - [ ] Update on `user:offline` event
  - [ ] Query on page load to show initial presence

- [ ] Optimize presence updates (AC: 6)
  - [ ] Only broadcast to users in same table(s)
  - [ ] Throttle status updates (max 1 per 5 seconds)
  - [ ] Use Redis for presence state (optional for MVP)
  - [ ] Handle rapid connect/disconnect gracefully

- [x] Add typing indicator UI component (AC: 3)
  - [x] Position below chat input area
  - [x] Show animated dots: "Alice is typing..."
  - [x] Use gray text color
  - [x] Fade in/out animation (pulse)
  - [x] Limit height to 1 line

- [ ] Add presence indicator to member list (AC: 1)
  - [ ] Green dot (bg-green-neon) for online
  - [ ] Gray dot (bg-gray-600) for offline
  - [ ] Position dot on avatar (bottom-right corner)
  - [ ] Add tooltip: "Online" or "Last seen 5m ago"

- [x] Handle edge cases
  - [x] Prevent spam (throttle typing events)
  - [ ] Handle rapid reconnects
  - [ ] Clear typing indicator on disconnect
  - [ ] Sync presence state on reconnect

## Dev Notes

### Presence System Flow
**[Source: Architecture Section 5.3.2 - Presence Events]**

```
┌──────────────────────────────────────────────────────────┐
│ CLIENT A (Alice)                                         │
│                                                          │
│ 1. Socket connects                                      │
│ 2. Emits: user:online { userId: "clxxx" }               │
│                                                          │
│ 3. Types in chat input                                  │
│ 4. Emits: typing:start { tableId, userId }              │
│                                                          │
│ 5. Stops typing (3s idle)                               │
│ 6. Emits: typing:stop { tableId, userId }               │
└──────────────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────────────┐
│ SERVER                                                   │
│                                                          │
│ 1. Receives user:online                                 │
│ 2. Updates DB: user.onlineStatus = "online"             │
│ 3. Broadcasts: presence:update to all table rooms       │
│                                                          │
│ 4. Receives typing:start                                │
│ 5. Broadcasts to table:clxxx room                       │
│                                                          │
│ 6. Receives typing:stop                                 │
│ 7. Broadcasts to table:clxxx room                       │
└──────────────────────────────────────────────────────────┘
                        ↓
┌──────────────────────────────────────────────────────────┐
│ CLIENTS B, C, D (Bob, Carol, Dave)                       │
│                                                          │
│ 1. Receive: presence:update { userId, status: "online" }│
│ 2. Update member list: show green dot for Alice         │
│                                                          │
│ 3. Receive: typing:start { userId: "clxxx" }            │
│ 4. Show: "Alice is typing..."                           │
│                                                          │
│ 5. Receive: typing:stop { userId: "clxxx" }             │
│ 6. Hide typing indicator for Alice                      │
└──────────────────────────────────────────────────────────┘
```

### Socket.io Presence Events
**[Source: Architecture Section 5.3.2]**

```typescript
// apps/api/src/socket/presence.socket.ts
import { Server as SocketIOServer, Socket } from 'socket.io';
import { prisma } from '@iarpg/db';

export function setupPresenceSocket(io: SocketIOServer) {
  io.on('connection', (socket: Socket) => {
    const userId = socket.data.userId;

    // User comes online
    socket.on('user:online', async () => {
      if (!userId) return;

      // Update database
      await prisma.user.update({
        where: { id: userId },
        data: {
          onlineStatus: 'online',
          lastSeenAt: new Date(),
        },
      });

      // Get user's active tables
      const memberships = await prisma.tableMember.findMany({
        where: { userId },
        select: { tableId: true },
      });

      // Broadcast to all user's tables
      memberships.forEach(({ tableId }) => {
        io.to(`table:${tableId}`).emit('presence:update', {
          userId,
          status: 'online',
        });
      });
    });

    // User goes offline (with timeout)
    socket.on('disconnect', async () => {
      if (!userId) return;

      // Wait 30 seconds before marking offline (reconnection grace period)
      setTimeout(async () => {
        // Check if user has any active sockets
        const userSockets = await io.in(`user:${userId}`).allSockets();
        if (userSockets.size > 0) return; // Still connected elsewhere

        await prisma.user.update({
          where: { id: userId },
          data: {
            onlineStatus: 'offline',
            lastSeenAt: new Date(),
          },
        });

        const memberships = await prisma.tableMember.findMany({
          where: { userId },
          select: { tableId: true },
        });

        memberships.forEach(({ tableId }) => {
          io.to(`table:${tableId}`).emit('presence:update', {
            userId,
            status: 'offline',
          });
        });
      }, 30000); // 30-second timeout
    });

    // Typing indicators
    socket.on('typing:start', ({ tableId }: { tableId: string }) => {
      socket.to(`table:${tableId}`).emit('typing:start', {
        userId,
        username: socket.data.username,
      });
    });

    socket.on('typing:stop', ({ tableId }: { tableId: string }) => {
      socket.to(`table:${tableId}`).emit('typing:stop', { userId });
    });
  });
}
```

### Typing Indicator Hook
```typescript
// apps/web/src/hooks/useTypingIndicator.ts
import { useEffect, useState, useCallback } from 'react';
import { useSocketContext } from '@/contexts/SocketContext';
import { debounce } from 'lodash';

export function useTypingIndicator(tableId: string) {
  const { socket } = useSocketContext();
  const [isTyping, setIsTyping] = useState(false);
  const [typingUsers, setTypingUsers] = useState<Set<string>>(new Set());

  // Debounced emit typing:start (throttle to max 1 per 500ms)
  const emitTypingStart = useCallback(
    debounce(() => {
      if (!socket) return;
      socket.emit('typing:start', { tableId });
    }, 500),
    [socket, tableId]
  );

  // Emit typing:stop after 3 seconds of inactivity
  const emitTypingStop = useCallback(
    debounce(() => {
      if (!socket) return;
      socket.emit('typing:stop', { tableId });
      setIsTyping(false);
    }, 3000),
    [socket, tableId]
  );

  // Call this when user types
  const handleTyping = () => {
    if (!isTyping) {
      setIsTyping(true);
      emitTypingStart();
    }
    emitTypingStop(); // Reset 3s timeout
  };

  // Call this when user sends message
  const handleStopTyping = () => {
    if (!socket) return;
    socket.emit('typing:stop', { tableId });
    setIsTyping(false);
    emitTypingStart.cancel();
    emitTypingStop.cancel();
  };

  // Listen for typing events from others
  useEffect(() => {
    if (!socket) return;

    socket.on('typing:start', ({ userId, username }: { userId: string; username: string }) => {
      setTypingUsers((prev) => new Set([...prev, username]));

      // Auto-remove after 3 seconds (in case typing:stop is missed)
      setTimeout(() => {
        setTypingUsers((prev) => {
          const updated = new Set(prev);
          updated.delete(username);
          return updated;
        });
      }, 3000);
    });

    socket.on('typing:stop', ({ userId }: { userId: string }) => {
      setTypingUsers((prev) => {
        const updated = new Set(prev);
        // Remove by userId (need to map userId to username)
        return updated;
      });
    });

    return () => {
      socket.off('typing:start');
      socket.off('typing:stop');
    };
  }, [socket]);

  return {
    handleTyping,
    handleStopTyping,
    typingUsers: Array.from(typingUsers),
  };
}
```

### Typing Indicator Component
```typescript
interface TypingIndicatorProps {
  typingUsers: string[];
}

export function TypingIndicator({ typingUsers }: TypingIndicatorProps) {
  if (typingUsers.length === 0) return null;

  const formatTypingUsers = () => {
    if (typingUsers.length === 1) {
      return `${typingUsers[0]} is typing`;
    } else if (typingUsers.length === 2) {
      return `${typingUsers[0]} and ${typingUsers[1]} are typing`;
    } else if (typingUsers.length === 3) {
      return `${typingUsers[0]}, ${typingUsers[1]}, and ${typingUsers[2]} are typing`;
    } else {
      return `${typingUsers[0]}, ${typingUsers[1]}, and ${typingUsers.length - 2} others are typing`;
    }
  };

  return (
    <div className="px-4 py-2 text-small text-gray-400 italic animate-fade-in">
      {formatTypingUsers()}
      <span className="animate-pulse">...</span>
    </div>
  );
}
```

### Chat Input with Typing Indicator
```typescript
export function ChatInput({ tableId }: { tableId: string }) {
  const [content, setContent] = useState('');
  const { handleTyping, handleStopTyping, typingUsers } = useTypingIndicator(tableId);

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
    handleTyping();
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim()) return;

    // Send message
    await sendMessage(content);

    setContent('');
    handleStopTyping(); // Clear typing indicator
  };

  return (
    <div>
      <TypingIndicator typingUsers={typingUsers} />

      <form onSubmit={handleSubmit} className="p-4 border-t border-gray-800">
        <div className="flex gap-2">
          <Textarea
            value={content}
            onChange={handleChange}
            placeholder="Type a message..."
          />
          <Button type="submit">Send</Button>
        </div>
      </form>
    </div>
  );
}
```

### Presence Update Hook
```typescript
// apps/web/src/hooks/usePresence.ts
import { useEffect, useState } from 'react';
import { useSocketContext } from '@/contexts/SocketContext';

interface PresenceState {
  [userId: string]: 'online' | 'offline';
}

export function usePresence(tableId: string) {
  const { socket } = useSocketContext();
  const [presence, setPresence] = useState<PresenceState>({});

  useEffect(() => {
    if (!socket) return;

    // Emit user:online when socket connects
    socket.emit('user:online');

    // Listen for presence updates
    socket.on('presence:update', ({ userId, status }: { userId: string; status: string }) => {
      setPresence((prev) => ({
        ...prev,
        [userId]: status as 'online' | 'offline',
      }));
    });

    return () => {
      socket.off('presence:update');
    };
  }, [socket]);

  return presence;
}
```

### Member List with Presence
```typescript
export function MemberList({ members, tableId }: MemberListProps) {
  const presence = usePresence(tableId);

  return (
    <div className="p-4">
      <h2 className="text-h4 font-bold mb-4">Members</h2>

      <div className="space-y-3">
        {members.map((member) => {
          const isOnline = presence[member.userId] === 'online';

          return (
            <div key={member.id} className="flex items-center gap-3">
              <div className="relative">
                <Avatar className="h-10 w-10">
                  <AvatarImage src={member.user.avatar} />
                  <AvatarFallback>{member.user.username[0]}</AvatarFallback>
                </Avatar>

                {/* Presence indicator */}
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <span
                        className={`absolute bottom-0 right-0 h-3 w-3 rounded-full border-2 border-black ${
                          isOnline ? 'bg-green-neon' : 'bg-gray-600'
                        }`}
                      />
                    </TooltipTrigger>
                    <TooltipContent>
                      {isOnline ? 'Online' : `Last seen ${formatLastSeen(member.user.lastSeenAt)}`}
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>

              <div className="flex-1">
                <p className="font-medium">{member.user.username}</p>
                <p className="text-small text-gray-400">
                  {member.character?.name} • {member.character?.class}
                </p>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

### Database Schema Update
**[Source: Architecture Section 4.1 - User Model]**

```prisma
model User {
  id           String   @id @default(cuid())
  email        String   @unique
  username     String   @unique
  onlineStatus String   @default("offline") // online, offline, away
  lastSeenAt   DateTime @default(now())
  // ... other fields
}
```

### Migration
```sql
-- Add presence fields to User table
ALTER TABLE "User"
ADD COLUMN "onlineStatus" TEXT DEFAULT 'offline',
ADD COLUMN "lastSeenAt" TIMESTAMP DEFAULT NOW();

CREATE INDEX "User_onlineStatus_idx" ON "User"("onlineStatus");
```

### Optimize with Redis (Optional)
```typescript
// For high-scale, use Redis for presence instead of database
import { Redis } from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// Set user online (with 5-minute TTL)
await redis.setex(`presence:${userId}`, 300, 'online');

// Check user presence
const status = await redis.get(`presence:${userId}`);
const isOnline = status === 'online';

// Extend TTL on activity
socket.on('typing:start', async () => {
  await redis.expire(`presence:${userId}`, 300);
});
```

### Helper Functions
```typescript
// Format last seen timestamp
function formatLastSeen(lastSeenAt: Date | string): string {
  const d = new Date(lastSeenAt);
  const now = new Date();
  const diffMs = now.getTime() - d.getTime();
  const diffMins = Math.floor(diffMs / 60000);

  if (diffMins < 1) return 'just now';
  if (diffMins < 60) return `${diffMins}m ago`;

  const diffHours = Math.floor(diffMins / 60);
  if (diffHours < 24) return `${diffHours}h ago`;

  const diffDays = Math.floor(diffHours / 24);
  return `${diffDays}d ago`;
}
```

### Testing

**Test scenarios:**
- User status changes to online when socket connects
- User status changes to offline after disconnect (30s timeout)
- Green dot shows for online users in member list
- Typing indicator appears when user types
- Typing indicator disappears after 3 seconds of inactivity
- Typing indicator clears when message is sent
- Multiple users typing shows correct format
- Presence updates in real-time across multiple clients
- Reconnect updates presence correctly
- Last seen timestamp displays correctly
- Typing events are throttled (max 1 per 500ms)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results

### Review Date: 2025-10-02
### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

**Overall**: ✅ **Well-Executed Typing Indicators**

The typing indicator implementation is clean, efficient, and user-friendly. The throttling mechanism prevents spam, the auto-clear functionality works smoothly, and the multi-user formatting is excellent. The useTypingIndicator hook demonstrates good React patterns with proper cleanup.

**Strengths:**
- Throttling (500ms) prevents event spam - excellent optimization
- Auto-clear after 3s of inactivity working perfectly
- Multi-user formatting logic handles 1-4+ users elegantly
- TypingIndicator component is simple and focused
- Typing stops correctly on message send
- useRef properly used for timeout management
- Memory cleanup on unmount prevents leaks

**Areas Pending Database:**
- Presence tracking (online/offline dots) not functional yet
- Requires User model fields: onlineStatus, lastSeenAt
- 30-second offline timeout logic exists but DB not connected

### Refactoring Performed

**Minor cleanup performed** - simplified typing indicator state management in table-page-client.tsx by moving logic inline instead of using the full useTypingIndicator hook (which was designed for standalone use).

### Compliance Check
- ✅ **Coding Standards**: Clean, well-structured hooks
- ✅ **Project Structure**: Proper hooks/ and components/ organization
- ✅ **Testing Strategy**: Manually tested throttling and multi-user
- ⚠️ **All ACs Met**: 3/8 complete (typing done, presence pending DB)

### Acceptance Criteria Validation

1. ⚠️ **Member list shows online status**: Not implemented (needs DB)
2. ⚠️ **Member list shows "typing..." indicator**: Separate component below chat, not in member list
3. ✅ **Typing indicator below chat input**: Working perfectly
4. ✅ **Clears after 3s inactivity**: Auto-clear timeout functional
5. ✅ **Multiple users typing format**: All formats working (1, 2, 3, 4+ users)
6. ⚠️ **Online status updates real-time**: Socket events exist but DB missing
7. ⚠️ **Offline after 30s timeout**: Server logic exists but DB missing
8. ⚠️ **Presence persists across refreshes**: Requires DB persistence

### Improvements Checklist

#### Completed (Typing Indicators)
- [x] Throttled typing:start emit (500ms)
- [x] Auto-clear after 3s idle
- [x] Typing cleared on message send
- [x] TypingIndicator component with smart formatting
- [x] Handle 1, 2, 3, 4+ users typing
- [x] Animated pulse on "..." text
- [x] Memory cleanup on unmount
- [x] Integration in both desktop/mobile layouts

#### Pending (Presence System)
- [ ] **Database schema**: Add onlineStatus, lastSeenAt to User model
- [ ] **user:online event handler**: Update DB on socket connect
- [ ] **user:offline event handler**: Update DB on disconnect (30s timeout)
- [ ] **presence:update broadcast**: Send to table rooms
- [ ] **usePresence hook**: Client-side presence state management
- [ ] **Green/gray dots on avatars**: Visual presence indicators
- [ ] **Tooltip with last seen**: "Online" vs "Last seen 5m ago"
- [ ] **Presence persistence**: Query DB on page load

### Security Review

✅ **No security concerns for typing indicators**

- Events are broadcast only to table rooms (proper isolation)
- Throttling prevents spam attacks
- No sensitive data in typing events

**Presence system recommendations**:
- Validate userId in presence events on backend
- Add rate limiting for presence updates
- Consider Redis for scalability (optional)

### Performance Considerations

✅ **Typing indicators are highly optimized**

- Throttling (500ms) reduces unnecessary socket emits
- Timeout cleanup prevents memory leaks
- State updates are minimal and efficient
- No performance degradation observed

**Presence system considerations**:
- Database updates on every online/offline event could be expensive
- **Recommendation**: Batch presence updates or use Redis
- **Recommendation**: Only update lastSeenAt every 5 minutes, not on every event

### Testing Observations

**What Works Perfectly**:
- Single user typing: "Alice is typing..."
- Two users: "Alice and Bob are typing..."
- Three users: "Alice, Bob, and Carol are typing..."
- Four+ users: "Alice, Bob, and 2 others are typing..."
- Auto-clear after 3s when user stops
- Clear on message send
- Throttling prevents rapid emits

**What Needs Testing (Post-DB)**:
- Presence dots appearing correctly
- 30s offline timeout
- Last seen timestamps
- Multi-tab behavior (same user, multiple tabs)
- Reconnection handling

### Final Status

✅ **APPROVED FOR MVP - Typing Indicators Complete**
⚠️ **PRESENCE TRACKING DEFERRED** (Requires Database Sprint)

**Summary**: The typing indicator implementation is production-ready and adds significant UX value. Users can see when others are composing messages, with smart formatting for multiple typers. Presence tracking (online dots) is architecturally planned but requires database integration before it can function.

**For MVP Demo**: ✅ Typing indicators fully functional
**For Production**: ✅ Typing ready, ⚠️ Presence needs DB sprint

**Recommendations**:

#### Immediate (Pre-MVP):
None - typing indicators are complete and polished.

#### Next Sprint (Presence):
1. **Database Migration**: Add onlineStatus, lastSeenAt to User model
2. **Backend Handlers**: Implement user:online and disconnect DB updates
3. **Frontend Hook**: Create usePresence() hook for client state
4. **UI Integration**: Add presence dots to member avatars
5. **Optimization**: Consider Redis for presence (if scaling beyond 100 concurrent users)

#### Future Enhancements:
- Show "Last seen" timestamp on hover
- Add "Away" status for idle users
- Typing indicator in member list (in addition to below chat)
- Sound notification on typing start (optional)

**Overall Assessment**: Excellent implementation within MVP scope. Architecture supports future presence features cleanly.
