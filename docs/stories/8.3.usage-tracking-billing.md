# Story 8.3: Usage Tracking & Billing Dashboard

## Status
Draft

## Story
**As a** platform owner,
**I want** to track AI usage and costs per user,
**so that** I can monitor expenses and optimize pricing.

## Acceptance Criteria
1. All AI API calls logged in `AIUsage` table with token count and cost
2. Admin dashboard shows total AI usage, costs, and revenue
3. Per-user usage statistics available in admin panel
4. Monthly usage reports generated automatically
5. Cost calculation accurate (Claude API pricing: $3/1M input, $15/1M output)
6. Usage dashboard shows breakdown by feature (DM assist, NPC dialogue, combat suggestions)
7. Alerts triggered when daily costs exceed threshold
8. Export usage data to CSV for accounting

## Tasks / Subtasks

- [ ] Ensure AIUsage model tracks all needed fields (AC: 1, 5)
  - [ ] Verify fields: userId, tableId, prompt, response, tokensUsed, cost, createdAt
  - [ ] Add `feature` field (dm_assist, npc_dialogue, combat_suggestion, plot_assist)
  - [ ] Add `model` field (claude-3-5-sonnet-20241022, etc.)
  - [ ] Run migration if needed

- [ ] Create cost calculation utility (AC: 5)
  - [ ] Function `calculateCost(inputTokens, outputTokens, model)`
  - [ ] Claude 3.5 Sonnet pricing: $3/1M input, $15/1M output
  - [ ] Handle different models (future-proof)
  - [ ] Return cost in dollars (e.g., 0.0045)

- [ ] Update all AI endpoints to log usage (AC: 1)
  - [ ] DM assist endpoint logs: feature = 'dm_assist'
  - [ ] NPC dialogue endpoint logs: feature = 'npc_dialogue'
  - [ ] Combat suggestion endpoint logs: feature = 'combat_suggestion'
  - [ ] Plot assistant endpoint logs: feature = 'plot_assist'
  - [ ] Record input/output tokens separately

- [ ] Build admin dashboard page (AC: 2)
  - [ ] Page: `/admin/usage`
  - [ ] Requires admin role (add `role` field to User model)
  - [ ] Shows: total tokens, total cost, total revenue
  - [ ] Date range selector (last 7 days, 30 days, all time)
  - [ ] Charts: usage over time, cost per feature

- [ ] Create admin usage API (AC: 2, 3)
  - [ ] GET `/api/admin/usage/summary` - total stats
  - [ ] GET `/api/admin/usage/by-user` - per-user breakdown
  - [ ] GET `/api/admin/usage/by-feature` - per-feature breakdown
  - [ ] Query params: startDate, endDate
  - [ ] Aggregates: SUM(tokensUsed), SUM(cost), COUNT(*)

- [ ] Implement per-user usage view (AC: 3)
  - [ ] Table: username, tier, total tokens, total cost, last active
  - [ ] Sort by cost (descending)
  - [ ] Click user → detailed breakdown
  - [ ] Shows usage by feature, by table

- [ ] Build monthly report generator (AC: 4)
  - [ ] Background job runs on 1st of each month
  - [ ] Aggregates previous month's usage
  - [ ] Generates report: total users, total cost, revenue, profit
  - [ ] Saves to `MonthlyReport` table
  - [ ] Sends email to admin with summary

- [ ] Create MonthlyReport model (AC: 4)
  - [ ] Fields: month, year, totalUsers, totalCost, totalRevenue, profit
  - [ ] Calculated: profit = revenue - cost
  - [ ] Index on (year, month)

- [ ] Add usage breakdown by feature (AC: 6)
  - [ ] Query AIUsage grouped by `feature`
  - [ ] Chart: pie chart or bar chart
  - [ ] Shows: DM Assist (45%), Combat (30%), NPC Dialogue (20%), Plot (5%)

- [ ] Implement cost alert system (AC: 7)
  - [ ] Background job checks daily cost at end of day
  - [ ] If cost > threshold (e.g., $50/day), send email alert
  - [ ] Alert includes: cost, top users, recommendation
  - [ ] Threshold configurable in .env: `DAILY_COST_THRESHOLD`

- [ ] Build CSV export feature (AC: 8)
  - [ ] GET `/api/admin/usage/export` - returns CSV
  - [ ] Query params: startDate, endDate, userId (optional)
  - [ ] CSV columns: date, user, tier, feature, tokens, cost
  - [ ] Download as `usage-report-YYYY-MM-DD.csv`

- [ ] Add admin role to User model (AC: 2)
  - [ ] Add `role` field: user, admin (default: user)
  - [ ] Create middleware `requireAdmin()`
  - [ ] Apply to all `/api/admin/*` routes

- [ ] Create usage dashboard charts (AC: 2, 6)
  - [ ] Line chart: daily cost over time
  - [ ] Bar chart: cost per feature
  - [ ] Table: top 10 users by cost
  - [ ] Use Chart.js or Recharts

- [ ] Handle edge cases (AC: 1, 5)
  - [ ] AI API fails → don't log usage (no tokens returned)
  - [ ] Zero-cost features (cached responses) → log but cost = 0
  - [ ] Missing token count → estimate from characters (rough)
  - [ ] Failed payments → exclude from revenue calculation

## Dev Notes

### AIUsage Model Update
**[Source: PRD Section 3.3 - Usage Tracking]**

```prisma
model AIUsage {
  id          String   @id @default(cuid())
  userId      String
  tableId     String?
  feature     String   // dm_assist, npc_dialogue, combat_suggestion, plot_assist
  model       String   // claude-3-5-sonnet-20241022
  prompt      String   @db.Text
  response    String   @db.Text
  inputTokens Int
  outputTokens Int
  tokensUsed  Int      // inputTokens + outputTokens (for backward compatibility)
  cost        Float    // in dollars (e.g., 0.0045)
  createdAt   DateTime @default(now())

  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  table Table? @relation(fields: [tableId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([feature, createdAt])
  @@index([createdAt])
}

model User {
  role String @default("user") // user, admin
  // ... existing fields
}

model MonthlyReport {
  id           String   @id @default(cuid())
  month        Int      // 1-12
  year         Int      // 2025
  totalUsers   Int
  totalCost    Float
  totalRevenue Float
  profit       Float    // revenue - cost
  createdAt    DateTime @default(now())

  @@unique([year, month])
  @@index([year, month])
}
```

**Migration:**
```bash
npx prisma migrate dev --name add_usage_tracking_fields
```

### Cost Calculation Utility
**[Source: Claude API Pricing - January 2025]**

```typescript
// apps/api/src/utils/costCalculator.ts

// Pricing in dollars per 1M tokens
const MODEL_PRICING = {
  'claude-3-5-sonnet-20241022': {
    input: 3.0 / 1_000_000,   // $3 per 1M input tokens
    output: 15.0 / 1_000_000, // $15 per 1M output tokens
  },
  'claude-3-opus-20240229': {
    input: 15.0 / 1_000_000,
    output: 75.0 / 1_000_000,
  },
  'claude-3-haiku-20240307': {
    input: 0.25 / 1_000_000,
    output: 1.25 / 1_000_000,
  },
};

export function calculateCost(
  inputTokens: number,
  outputTokens: number,
  model: string
): number {
  const pricing = MODEL_PRICING[model];

  if (!pricing) {
    console.warn(`Unknown model pricing for ${model}, using Sonnet pricing`);
    const defaultPricing = MODEL_PRICING['claude-3-5-sonnet-20241022'];
    return (
      inputTokens * defaultPricing.input +
      outputTokens * defaultPricing.output
    );
  }

  const cost = inputTokens * pricing.input + outputTokens * pricing.output;
  return parseFloat(cost.toFixed(6)); // Round to 6 decimal places
}

// Example usage:
// calculateCost(1000, 500, 'claude-3-5-sonnet-20241022')
// = 1000 * 0.000003 + 500 * 0.000015
// = 0.003 + 0.0075
// = 0.0105 dollars (~1 cent)
```

### Updated AI Endpoints with Usage Logging
**[Source: Architecture Section 5.1.8 - AI Service Integration]**

```typescript
// apps/api/src/controllers/dmAssist.controller.ts (updated)
import { anthropic } from '../lib/anthropic';
import { prisma } from '@iarpg/db';
import { calculateCost } from '../utils/costCalculator';

export const dmAssistController = {
  async generateResponse(req: Request, res: Response, next: NextFunction) {
    try {
      const userId = req.user!.id;
      const { tableId } = req.params;
      const { prompt } = req.body;

      const model = 'claude-3-5-sonnet-20241022';

      const response = await anthropic.messages.create({
        model,
        max_tokens: 2048,
        system: 'You are a helpful D&D 5e Dungeon Master...',
        messages: [{ role: 'user', content: prompt }],
      });

      const responseText = response.content[0].text;
      const inputTokens = response.usage.input_tokens;
      const outputTokens = response.usage.output_tokens;
      const cost = calculateCost(inputTokens, outputTokens, model);

      // Log usage
      await prisma.aIUsage.create({
        data: {
          userId,
          tableId,
          feature: 'dm_assist',
          model,
          prompt,
          response: responseText,
          inputTokens,
          outputTokens,
          tokensUsed: inputTokens + outputTokens,
          cost,
        },
      });

      res.json({ response: responseText });
    } catch (error) {
      next(error);
    }
  },
};
```

### Admin Dashboard Page
**[Source: Front-End Spec Section 6.1 - Admin Dashboard]**

```typescript
// apps/web/src/app/admin/usage/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Line } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';

ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

interface UsageSummary {
  totalTokens: number;
  totalCost: number;
  totalRevenue: number;
  profit: number;
  dailyCosts: { date: string; cost: number }[];
  featureBreakdown: { feature: string; cost: number }[];
}

export default function AdminUsagePage() {
  const [summary, setSummary] = useState<UsageSummary | null>(null);
  const [dateRange, setDateRange] = useState('30');

  useEffect(() => {
    fetchSummary();
  }, [dateRange]);

  const fetchSummary = async () => {
    const response = await fetch(`/api/admin/usage/summary?days=${dateRange}`);
    const data = await response.json();
    setSummary(data);
  };

  if (!summary) return <div>Loading...</div>;

  const chartData = {
    labels: summary.dailyCosts.map((d) => d.date),
    datasets: [
      {
        label: 'Daily Cost ($)',
        data: summary.dailyCosts.map((d) => d.cost),
        borderColor: 'rgb(59, 130, 246)',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        tension: 0.3,
      },
    ],
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-3xl font-bold">Usage & Billing</h1>

        <Select value={dateRange} onValueChange={setDateRange}>
          <SelectTrigger className="w-40">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="7">Last 7 days</SelectItem>
            <SelectItem value="30">Last 30 days</SelectItem>
            <SelectItem value="90">Last 90 days</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm text-gray-400">Total Tokens</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-3xl font-bold">
              {summary.totalTokens.toLocaleString()}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="text-sm text-gray-400">Total Cost</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-3xl font-bold text-red-500">
              ${summary.totalCost.toFixed(2)}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="text-sm text-gray-400">Total Revenue</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-3xl font-bold text-green-500">
              ${summary.totalRevenue.toFixed(2)}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="text-sm text-gray-400">Profit</CardTitle>
          </CardHeader>
          <CardContent>
            <p className={`text-3xl font-bold ${summary.profit > 0 ? 'text-green-500' : 'text-red-500'}`}>
              ${summary.profit.toFixed(2)}
            </p>
          </CardContent>
        </Card>
      </div>

      <Card className="mb-8">
        <CardHeader>
          <CardTitle>Daily Costs</CardTitle>
        </CardHeader>
        <CardContent>
          <Line data={chartData} options={{ responsive: true }} />
        </CardContent>
      </Card>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <Card>
          <CardHeader>
            <CardTitle>Cost by Feature</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {summary.featureBreakdown.map((feature) => (
                <div key={feature.feature} className="flex items-center justify-between">
                  <span className="capitalize">{feature.feature.replace('_', ' ')}</span>
                  <span className="font-bold">${feature.cost.toFixed(2)}</span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Actions</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            <button
              onClick={() => window.open('/api/admin/usage/export?days=' + dateRange, '_blank')}
              className="w-full px-4 py-2 bg-blue-600 rounded hover:bg-blue-700"
            >
              Export to CSV
            </button>

            <button
              onClick={() => window.location.href = '/admin/users'}
              className="w-full px-4 py-2 bg-gray-700 rounded hover:bg-gray-600"
            >
              View User Breakdown
            </button>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

### Admin Usage API
```typescript
// apps/api/src/controllers/adminUsage.controller.ts
import { Request, Response, NextFunction } from 'express';
import { prisma } from '@iarpg/db';

export const adminUsageController = {
  async getSummary(req: Request, res: Response, next: NextFunction) {
    try {
      const days = parseInt(req.query.days as string) || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // Total stats
      const totalUsage = await prisma.aIUsage.aggregate({
        where: { createdAt: { gte: startDate } },
        _sum: { tokensUsed: true, cost: true },
      });

      // Daily costs
      const dailyUsage = await prisma.$queryRaw<{ date: string; cost: number }[]>`
        SELECT
          DATE(createdAt) as date,
          SUM(cost) as cost
        FROM AIUsage
        WHERE createdAt >= ${startDate}
        GROUP BY DATE(createdAt)
        ORDER BY date ASC
      `;

      // Feature breakdown
      const featureUsage = await prisma.aIUsage.groupBy({
        by: ['feature'],
        where: { createdAt: { gte: startDate } },
        _sum: { cost: true },
      });

      // Revenue (from subscriptions)
      const revenue = await calculateRevenue(startDate);

      res.json({
        totalTokens: totalUsage._sum.tokensUsed || 0,
        totalCost: totalUsage._sum.cost || 0,
        totalRevenue: revenue,
        profit: revenue - (totalUsage._sum.cost || 0),
        dailyCosts: dailyUsage.map((d) => ({
          date: d.date.toString(),
          cost: parseFloat(d.cost.toString()),
        })),
        featureBreakdown: featureUsage.map((f) => ({
          feature: f.feature,
          cost: f._sum.cost || 0,
        })),
      });
    } catch (error) {
      next(error);
    }
  },

  async getByUser(req: Request, res: Response, next: NextFunction) {
    try {
      const days = parseInt(req.query.days as string) || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const userUsage = await prisma.aIUsage.groupBy({
        by: ['userId'],
        where: { createdAt: { gte: startDate } },
        _sum: { tokensUsed: true, cost: true },
        _count: true,
      });

      // Fetch user details
      const userIds = userUsage.map((u) => u.userId);
      const users = await prisma.user.findMany({
        where: { id: { in: userIds } },
        select: { id: true, username: true, tier: true, email: true },
      });

      const result = userUsage.map((usage) => {
        const user = users.find((u) => u.id === usage.userId);
        return {
          userId: usage.userId,
          username: user?.username || 'Unknown',
          email: user?.email || '',
          tier: user?.tier || 'free',
          totalTokens: usage._sum.tokensUsed || 0,
          totalCost: usage._sum.cost || 0,
          requestCount: usage._count,
        };
      });

      // Sort by cost descending
      result.sort((a, b) => b.totalCost - a.totalCost);

      res.json({ users: result });
    } catch (error) {
      next(error);
    }
  },

  async exportCSV(req: Request, res: Response, next: NextFunction) {
    try {
      const days = parseInt(req.query.days as string) || 30;
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const usage = await prisma.aIUsage.findMany({
        where: { createdAt: { gte: startDate } },
        include: {
          user: { select: { username: true, tier: true } },
        },
        orderBy: { createdAt: 'desc' },
      });

      // Generate CSV
      const csv = [
        'Date,User,Tier,Feature,Model,Input Tokens,Output Tokens,Cost',
        ...usage.map((u) =>
          [
            new Date(u.createdAt).toISOString(),
            u.user.username,
            u.user.tier,
            u.feature,
            u.model,
            u.inputTokens,
            u.outputTokens,
            u.cost.toFixed(6),
          ].join(',')
        ),
      ].join('\n');

      res.setHeader('Content-Type', 'text/csv');
      res.setHeader(
        'Content-Disposition',
        `attachment; filename=usage-report-${new Date().toISOString().split('T')[0]}.csv`
      );
      res.send(csv);
    } catch (error) {
      next(error);
    }
  },
};

async function calculateRevenue(startDate: Date): Promise<number> {
  // Calculate subscription revenue
  // Count active premium ($9.99) and master ($19.99) subscriptions
  const activeSubscriptions = await prisma.user.groupBy({
    by: ['tier'],
    where: {
      tier: { in: ['premium', 'master'] },
      subscriptionStatus: 'active',
      createdAt: { gte: startDate },
    },
    _count: true,
  });

  let revenue = 0;
  for (const sub of activeSubscriptions) {
    if (sub.tier === 'premium') {
      revenue += sub._count * 9.99;
    } else if (sub.tier === 'master') {
      revenue += sub._count * 19.99;
    }
  }

  return revenue;
}
```

### Monthly Report Generator (Background Job)
```typescript
// apps/api/src/jobs/monthlyReport.ts
import cron from 'node-cron';
import { prisma } from '@iarpg/db';
import { sendEmail } from '../services/email.service';

export function startMonthlyReportGenerator() {
  // Run on 1st of each month at 3 AM
  cron.schedule('0 3 1 * *', async () => {
    console.log('Generating monthly report...');

    const now = new Date();
    const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const thisMonth = new Date(now.getFullYear(), now.getMonth(), 1);

    // Aggregate last month's usage
    const totalUsage = await prisma.aIUsage.aggregate({
      where: {
        createdAt: {
          gte: lastMonth,
          lt: thisMonth,
        },
      },
      _sum: { cost: true },
    });

    const totalCost = totalUsage._sum.cost || 0;

    // Count active users
    const totalUsers = await prisma.user.count({
      where: {
        createdAt: { lt: thisMonth },
      },
    });

    // Calculate revenue
    const subscriptions = await prisma.user.groupBy({
      by: ['tier'],
      where: {
        tier: { in: ['premium', 'master'] },
        subscriptionStatus: 'active',
      },
      _count: true,
    });

    let totalRevenue = 0;
    for (const sub of subscriptions) {
      if (sub.tier === 'premium') totalRevenue += sub._count * 9.99;
      if (sub.tier === 'master') totalRevenue += sub._count * 19.99;
    }

    const profit = totalRevenue - totalCost;

    // Save report
    const report = await prisma.monthlyReport.create({
      data: {
        month: lastMonth.getMonth() + 1,
        year: lastMonth.getFullYear(),
        totalUsers,
        totalCost,
        totalRevenue,
        profit,
      },
    });

    console.log(`Monthly report created: ${JSON.stringify(report)}`);

    // Send email to admin
    await sendEmail({
      to: process.env.ADMIN_EMAIL!,
      subject: `Monthly Report - ${lastMonth.toLocaleString('default', { month: 'long' })} ${lastMonth.getFullYear()}`,
      html: `
        <h2>Monthly Report</h2>
        <p><strong>Period:</strong> ${lastMonth.toLocaleString('default', { month: 'long' })} ${lastMonth.getFullYear()}</p>
        <p><strong>Total Users:</strong> ${totalUsers}</p>
        <p><strong>Total Cost:</strong> $${totalCost.toFixed(2)}</p>
        <p><strong>Total Revenue:</strong> $${totalRevenue.toFixed(2)}</p>
        <p><strong>Profit:</strong> $${profit.toFixed(2)}</p>
      `,
    });
  });

  console.log('Monthly report generator started');
}
```

### Cost Alert System
```typescript
// apps/api/src/jobs/costAlert.ts
import cron from 'node-cron';
import { prisma } from '@iarpg/db';
import { sendEmail } from '../services/email.service';

export function startCostAlertChecker() {
  // Run daily at 11 PM
  cron.schedule('0 23 * * *', async () => {
    console.log('Checking daily cost threshold...');

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const dailyUsage = await prisma.aIUsage.aggregate({
      where: {
        createdAt: { gte: today },
      },
      _sum: { cost: true },
    });

    const dailyCost = dailyUsage._sum.cost || 0;
    const threshold = parseFloat(process.env.DAILY_COST_THRESHOLD || '50');

    if (dailyCost > threshold) {
      console.warn(`⚠️ Daily cost ($${dailyCost.toFixed(2)}) exceeded threshold ($${threshold})`);

      // Get top users
      const topUsers = await prisma.aIUsage.groupBy({
        by: ['userId'],
        where: { createdAt: { gte: today } },
        _sum: { cost: true },
        orderBy: { _sum: { cost: 'desc' } },
        take: 5,
      });

      const userDetails = await prisma.user.findMany({
        where: { id: { in: topUsers.map((u) => u.userId) } },
        select: { id: true, username: true, email: true },
      });

      const topUsersHTML = topUsers
        .map((u) => {
          const user = userDetails.find((ud) => ud.id === u.userId);
          return `<li>${user?.username || 'Unknown'}: $${(u._sum.cost || 0).toFixed(2)}</li>`;
        })
        .join('');

      // Send alert email
      await sendEmail({
        to: process.env.ADMIN_EMAIL!,
        subject: `⚠️ Cost Alert: Daily threshold exceeded`,
        html: `
          <h2>Cost Alert</h2>
          <p><strong>Daily Cost:</strong> $${dailyCost.toFixed(2)}</p>
          <p><strong>Threshold:</strong> $${threshold.toFixed(2)}</p>
          <p><strong>Overage:</strong> $${(dailyCost - threshold).toFixed(2)}</p>

          <h3>Top Users Today:</h3>
          <ul>${topUsersHTML}</ul>

          <p><a href="${process.env.FRONTEND_URL}/admin/usage">View Full Dashboard</a></p>
        `,
      });
    }
  });

  console.log('Cost alert checker started');
}
```

**Start jobs in server.ts:**
```typescript
// apps/api/src/server.ts
import { startMonthlyReportGenerator } from './jobs/monthlyReport';
import { startCostAlertChecker } from './jobs/costAlert';

startMonthlyReportGenerator();
startCostAlertChecker();
```

### Admin Middleware
```typescript
// apps/api/src/middleware/admin.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { prisma } from '@iarpg/db';

export async function requireAdmin(req: Request, res: Response, next: NextFunction) {
  const userId = req.user!.id;

  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true },
  });

  if (!user || user.role !== 'admin') {
    return res.status(403).json({ error: 'Admin access required' });
  }

  next();
}
```

**Routes:**
```typescript
// apps/api/src/routes/admin.routes.ts
import express from 'express';
import { adminUsageController } from '../controllers/adminUsage.controller';
import { authenticate } from '../middleware/auth.middleware';
import { requireAdmin } from '../middleware/admin.middleware';

const router = express.Router();

router.get('/usage/summary', authenticate, requireAdmin, adminUsageController.getSummary);
router.get('/usage/by-user', authenticate, requireAdmin, adminUsageController.getByUser);
router.get('/usage/export', authenticate, requireAdmin, adminUsageController.exportCSV);

export default router;
```

### Testing

**Test scenarios:**
- All AI endpoints log usage to AIUsage table
- Cost calculated correctly based on token counts
- Admin dashboard shows total tokens, cost, revenue, profit
- Date range selector filters data correctly
- Daily cost chart displays accurate data
- Feature breakdown shows cost per feature (DM assist, NPC, combat)
- Per-user breakdown shows top users by cost
- CSV export downloads with correct data
- Monthly report generated on 1st of month
- Monthly report sent to admin email
- Cost alert triggers when threshold exceeded
- Cost alert email includes top users
- Admin routes require admin role
- Non-admin users blocked from admin endpoints

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story draft | Bob (SM) |

## Dev Agent Record
_To be filled by dev agent_

## QA Results
_To be filled by QA agent_
